<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux中文输入法]]></title>
    <url>%2FNotes%2F2019%2F06%2F10%2Flinux-%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[系统版本为 Ubuntu 16.04。 首先安装汉语语言包： 1$sudo apt install language-pack-zh-hans 安装谷歌拼音输入法。执行这个命令，系统会自动安装 fcitx，googlepinyin，以及一些 fcitx 配置程序： 1$sudo apt install fcitx-googlepinyin 打开 systemsettings -&gt; Language Support，系统会自动进行语言包搜索，按照系统提示确认安装。fcitx 是一个输入法框架。如图所示，在 Keyboard input method system 中选择 fcitx： 重启电脑，fcitx 输入法框架开始运行。在终端执行 fcitx-configtool，进行输入法配置。点击 “+” 添加Google Pinyin： 若列表里没有 Google Pinyin，需要取消 Only Show Current Language 复选框： 添加完输入法之后，在 Global Config 中可以看到输入法的切换方式： 以上。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文档</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux强化学习环境配置]]></title>
    <url>%2FNotes%2F2019%2F06%2F10%2Flinux-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Nvidia 驱动安装在 All Settings -&gt; Details 中查看自己的设备信息，如图： Nvidia 驱动和 CUDA 版本存在着对应关系，可以在官网查看。 这里可以查看 GPU 支持的驱动版本。 推荐使用 ppa 源安装驱动，方法如下： 首先添加 ppa 源，执行如下语句： 1$sudo add-apt-repository ppa:graphics-drivers/ppa 获取最新的软件包源，将其添加至当前 apt 库中，执行后会显示当前可供下载的最新驱动版本号，已经老的驱动版本号。如图： 最新的版本为 nvidia-410(410.66)，稍早的版本为 nvidia-390(390.87)。更新软件库信息，并下载 Nvidia 驱动： 12$sudo apt update$sudo apt install nvidia-390 安装三维图像库和 OpenGL 环境，并重启： 123$sudo apt install mesa-common-dev$sudo apt install freeglut3-dev$sudo reboot 在终端输入 nvidia-smi，若输出如下，则说明安装成功： All Setting -&gt; Details 内显示 Graphics 为 Geforce 920： 在 .bashrc 中添加路径：1$export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/nvidia-390 以上。 CUDA 安装以 cuda8 为例，参考博客。 很多博客都指出要先禁用 nouveau 服务，并加入黑名单，这个步骤很麻烦，同时也是没有必要的。首先，我们来看 nouveau 是什么。nouveau 是一个开源驱动项目，是 Linux KMS（kernel mode-setting）驱动的一部分，是一个公版的显卡驱动程序，可以驱动 AMD、高通的芯片，nvidia 也参与了开发，KMS 项目是为了在文本系统Linux中显示图形界面而诞生的开源项目。也就是说，这个 nouveau 和我们安装的 nvidia 驱动是冲突的，所以是要禁止掉的。但是，如果你的系统中两者并没有发生冲突，那么再处理这个公版驱动就没有必要了。CUDA 安装指南 Installation Guide for Linux 中指明了需要 Disable the Nouveau drivers，但是在具体如何禁用的时候，文档又指出了: The Nouveau drivers are loaded if the following command prints anything: 1$lsmod | grep nouveau 如果执行命令后什么也没有显示，则说明 Nouveau drivers 本身就没有被使用，是不用禁用的。 直接执行如下命令： 1$sudo sh cuda_8.0.61_375.26_linux.run 或者 1$sudo sh cuda_8.0.61_375.26_linux.run --no-opengl-libs # 更推荐这种方式 按照提示一步步安装即可，注意安装驱动的选项要选择 no。 然后安装补丁 Patch 2： 1$sudo sh cuda_8.0.61.2_linux.run 安装完成后，在环境变量中添加 CUDA，在 .bashrc 中添加： 12export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$LD_LIBRARY_PATH 重启电脑，即完成 CUDA 安装。 以上。 CUDNN 安装cudnn 需要注册 nvidia 账号才可以下载。共有三个文件： libcudnn6-dev_6.0.21-1+cuda8.0_amd64.deb libcudnn6_6.0.21-1+cuda8.0_amd64.deb libcudnn6-doc_6.0.21-1+cuda8.0_amd64.deb 命令行执行： 123$sudo dpkg -i libcudnn6-dev_6.0.21-1+cuda8.0_amd64.deb$sudo dpkg -i libcudnn6_6.0.21-1+cuda8.0_amd64.deb$sudo dpkg -i libcudnn6-doc_6.0.21-1+cuda8.0_amd64.deb 安装完毕后重启终端。 输入命令： 1$nvcc -V 会显示 CUDA 的版本号。 进入 ~/NVIDIA_CUDA-8.0_Sample/1_Utilities/deviceQuery/，执行 make 命令： 12$make$./deviceQuery 显示 Result = PASS。CUDA+CUDNN 安装成功。以上。 tensorflow 安装使用 pip 安装即可。首先，在 anaconda 中创建虚拟环境：1$conda create -n tf python=3.5 这里最好创建 python3.5 的环境，因为后面安装的包对更高版本的支持不是太好。tensorflow 的向下兼容性并不是很好，这里要选择好tensorflow的版本，tensorflow 和 CUDA 以及 cudnn 的版本对应关系如下，数据来自博客 tensorflow-gpu cuda cudnn python v1.9.0 9.0 7.1.4 2.7,3.3-3.6 v1.8.0 9.0 7 2.7,3.3-3.6 v1.7.0 9.0 7 2.7,3.3-3.6 v1.6.0 9.0 7 2.7,3.3-3.6 v1.5.0 9.0 7 2.7,3.3-3.6 v1.4.0 8.0 6.0 2.7,3.3-3.6 v1.3.0 8.0 6.0 2.7,3.3-3.6 v1.2.0 8.0 5.1 2.7,3.3-3.6 v1.1.0 8.0 5.1 2.7,3.3-3.6 根据之前安装的cuda和cudnn，我选择安装 tensorflow v1.4.0:12$source activate tf # 进入虚拟环境 tf$pip install tensorflow-gpu==1.4.0 # 若提示有包依赖，再安装便是 以上。 mujoco安装破解版的三个文件：mjkey.txt, mjpro150, mjpro150_linux.zip。 首先，在主目录下创建隐藏文件夹 mujoco，并将压缩包 mjpro150_linux.zip 解压到这里：1234$mkdir ~/.mujoco$cp mjpro150_linux.zip ~/.mujoco$cd ~/.mujoco$unzip mjpro150_linux.zip 然后，将 mjket.txt 复制到 ~/.mujoco 和 ~/.mujoco/mjpro150/bin :12$cp mjkey.txt ~/.mujoco$cp mjkey.txt ~/.mujoco/mjpro150/bin 复制 mjpro150 到 .mujoco 中，覆盖原有的 mjpro150 文件夹：1$cp -rf mjpro150 ~/.mujoco 修改文件执行权限：1$sudo chmod 777 -R .mujoco 然后添加环境变量，在 .bashrc 中添加：12export LD_LIBRARY_PATH=~/.mujoco/mjpro150/bin$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;export MUJOCO_KEY_PATH=~/.mujoco$&#123;MUJOCO_KEY_PATH&#125; 运行测试：12$cd ~/.mujoco/mjpro150/bin$./simulate ../model/humanoid.xml 以上。 mujoco_py 安装：首先，在 github 上下载源码：1$git clone https://github.com/openai/mujoco-py.git 下载下来的代码中包含 requirements.txt，需要先安装里面的依赖包：1$pip install -r requirements.txt 安装完依赖之后安装 mujoco_py：1$pip install -u 'mujoco-py&lt;1.50.2,&gt;=1.50.1' 安装过程中如果 gcc 报错，那么执行以下语句：1$sudo apt install libgl1-mesa-dev libgl1-mesa-glx libosmesa6-dev python3-pip python3-numpy python3-scipy 若出现错误：fatal error:GL/glew.g：没有那个文件或目录，解决方法：1sudo apt install libglew-dbg libglew-dev libglew1.10 libglew-dbg libglewmx-dev libglewmx1.13 glew-utils 安装完毕后，测试安装结果。1$cp -rf ~/Downloads/mujoco-py/xmls ~/.local/lib/python3.5/site-packages 然后执行 python 代码：12345678910import mujoco_pyfrom os.path import dirnamemodel = mujoco_py.load_model_from_path(dirname(dirname(mujoco_py.__file__))+"/xmls/claw.xml")sim = mujoco_py.MjSim(model)print(sim.data.qpos) # [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]sim.step()print(sim.data.qpos)# [2.09217903e‐06 ‐1.82329050e‐12 ‐1.16711384e‐07 ‐4.69613872e‐11# ‐1.43931860e‐05 4.73350204e‐10 ‐3.23749942e‐05 ‐1.19854057e‐13# ‐2.39251380e‐08 ‐4.46750545e‐07 1.78771599e‐09 ‐1.04232280e‐08] 以上。 安装 gym使用源码安装：1234$git clone https://github.com/openai/gym.git$cd gym$sudo apt install -y python-numpy python-dev cmake zlib1g-dev libjpeg-dev xvfb libav-tools xorg-dev python-opengl libboost-all-dev libsdl2-dev swig$pip install -e .[all] 运行测试程序：123456789101112import gymenv = gym.make('Hero-ram-v0')for i_episode in range(20): observation = env.reset() for t in range(100): env.render() print(observation) action = env.action_space.sample() observation,reward,done,info = env.step(action) if done: print("Episode finished after &#123;&#125; timesteps".format(t+1)) break 补充，安装需要依赖 cmake 和 zliblg-dev，1$sudo apt install cmake libz-dev 以上。 baseline 的安装baseline 需要 python3.5 及其以上的版本。安装依赖：1$sudo apt install libopenmpi-dev baseline 安装方法如下：123$git clone https://github.com/openai/baseline.git$cd baseline$pip install -e . 若出现错误 ERROR: GLEW initalization error: Missing GL version 解决办法为，在 .bashrc 中添加：1$export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libGLEW.so:/usr/lib/nvidia-390/libGL.so 若出现错误 AssertionError: TensorFlow needed, of version above 1.4 解决办法为：1$sudo ldconfig /usr/local/cuda/lib64/ 测试安装结果：12$cd ~/baseline/baseline/her/experiment/$python train.py --num_cpu=2 训练完毕后调用：1$python play.py /tmp/openai-2019-01-04-13-26-30-141299/policy_best.pkl # 后面这个参数是训练结束后输出的值 以上。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文档</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 随机数]]></title>
    <url>%2FNotes%2F2019%2F05%2F21%2FPython-%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有这样一个场景：在蛇棋游戏中，总共有 100 个格子，其中有 ladder_num 个格子中有梯子，梯子的作用是让棋子直通到另外一个格子中。用 python 实现梯子功能的代码片段如下： 123ladders = dict(np.random.randint(1, 100, size=(ladder_num, 2)))for k,v in ladders.items(): ladders[v] = k np.random.randint(1,100,size=(ladder_num, 2)) 意思是随机生成一个 ladder_num x 2 的二维数组，数组中每一个元素的大小在 1 到 100 之间。然后将二维数组转换为 dict，其中 key 代表起始的格子编号，value 代表指向的格子编号，梯子由 key 指向 value。再用一个循环将梯子由 value 指向 key，说明梯子是双向的。这里有两个问题。第一，随机数是不可控的，在 ladder_num 个数据对中很有可能会出现相同的数字，dict() 函数是有去重功能的，假设存在数据对 [[2,8],[2,15]]，那么最终保留在 dict 中的 key 值 2，对应的 value 只有 15。这就造成了数据丢失，若我们的目的是为了生成 10 个梯子，这样最终只能生成 9 个梯子。第二，假设随机生成的数据对为[...,[45,48],[65,68],[68,10],...]，那么后面的循环就会出现问题，因为dict中 key 65 对应的 value 为 68，循环中反转 kv，得到一个 key 68 指向 value 65，但是dict中已经有值为 68 的 key 了，它指向 value 10，这里就对原来的梯子做了修改。更严重的是，这里会报错RuntimeError: dictionary changed size during iteration，这是因为 Python 3 是不允许在遍历中修改字典大小的。 可以将代码修改如下：1234ladders = np.random.randint(1, 100, size=(ladder_num, 2))for k,v in ladders: ladders = np.vstack((ladders, np.array([v,k])))ladders = dict(ladders) 但是这样依然无法解决第一个问题，ladders 这个字典的大小依然可能小于我们希望的 ladder_num。为了得到不重复的 N 个随机数，我们有两个方法：第一，使用random.sample(range(A,B),N)函数，表示从[A,B]区间随机生成 N 个数，结果以列表返回。第二，使用 numpy 的函数np.random.sample(size)，该函数返回一个 size 数组，元素在[0.0, 1.0)区间：12345ladders = np.random.sample((ladder_num, 2)) * (100 - 0)ladders = ladders.astype(int)for k,v in ladders: ladders = np.vstack((ladders, np.array([v,k])))ladders = dict(ladders) 关于随机数 seed若不设置 seed，则每次会生成不同的随机数；若设置了 seed，则相当于设置了随机数生成的起点，后续生成的随机数都将是确定的。 1234567891011121314import randomrandom.seed()print ("使用默认种子生成随机数：&#123;&#125;".format(random.randint(1,5)))random.seed(10)for i in range(3): print ("使用种子10生成随机数：&#123;&#125;".format(random.randint(1,5))) print ("使用种子10生成随机数：&#123;&#125;".format(random.randint(1,5)))print("******************************")for i in range(3): random.seed(10) print ("使用种子10生成随机数：&#123;&#125;".format(random.randint(1,5))) print ("使用种子10生成随机数：&#123;&#125;".format(random.randint(1,5))) 第一个循环生成 6 个随机数：5，1，4，4，5，1。这相当于随机数种子 10 所能生成的随机数序列的前六个数字。第二个循环每次只取该序列的前两个数字：5，1。第二个循环的输出为：5，1，5，1，5，1。]]></content>
      <categories>
        <category>Python Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串]]></title>
    <url>%2FNotes%2F2019%2F05%2F21%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串的访问跟列表一样，用方括号访问，支持切片操作。python 支持格式化字符串的输出，最基本的用法是字符串中插入 %s： 12print("My name is %s." % ("LiLei"))str = "Her name is %s" % ("HanMeimei") 具体的字符串格式符同 C 语言一样。从 Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。其基本语法是通过 {} 和 : 来代替以前的 %。format() 函数可以接受不限个参数，位置可以不按顺序。12345&gt;&gt;&gt;"&#123;&#125; &#123;&#125;".format("hello", "world") # 不设置指定位置，按默认顺序'hello world'&gt;&gt;&gt;"&#123;0&#125; &#123;1&#125;".format("hello", "world") # 设置指定位置&gt;&gt;&gt;"&#123;0&#125; &#123;1&#125; &#123;0&#125;".format("hello", "world")hello world hello]]></content>
      <categories>
        <category>Python Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯 naive bayes]]></title>
    <url>%2FNotes%2F2019%2F02%2F27%2F%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF-naive-bayes%2F</url>
    <content type="text"><![CDATA[贝叶斯公式]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Guide]]></title>
    <url>%2FNotes%2F2019%2F01%2F23%2Flinux-guide%2F</url>
    <content type="text"><![CDATA[IntroductionLinuxLinux是一个免费的类 unix 操作系统，基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。以网络为核心，性能稳定。Windows 操作系统跟 Linux 操作系统在设计哲学上存在着巨大的区别。Windows 系统将各种功能都集中的操作系统内部，而 Linux 的内核空间与用户空间有明显的界限。Windows 的设计是为了让用户更方便的交互，所以对图形化界面 GUI 的支持特别好。Linux 操作系统以网络为核心，以文本为信息的载体，Linux 的核心设计思想为：一切皆为文件，所以它本质上是一个基于文本的命令行操作系统，图像对 Linux 系统来说是个包袱，Linux 对 GUI 的支持是很差的，GUI 在一定程度上会影响系统的稳定性，Linux 服务器均没有图形界面。 严格来讲，Linux 是指 Linux Kernel，我们平时用到的 Linux OS 一般都是基于这个 Kernel 制作的发行版（Redhat, debian, Centos, SuSE, Fedora等）。Ubuntu 基于debian，Centos 基于 Redhat，debian 基础核心小，稳定，占用资源少，Centos 去除了很多与服务器无关的应用，系统简单稳定。二者都是非常适合做服务器的操作系统。 Linux 本身没有图形界面，linux 是一个基于命令行的操作系统，图形界面得益于 X windows。 X WindowsX Windows (1984诞生于 MIT) 也被叫做“X”，“X 11”，是为了在 UNIX 系统上使用图形界面而开发的系统。X 一开始就是针对网络而设计的，采用了“client-server”模型，“X server”运行在计算机上，用来管理显示信息，处理来自键盘和鼠标的输入信息，并与其他输入输出设备交互。每一个 X 应用程序（比如 XTerm，Terminal，浏览器等）就是一个“X client”，客户给服务器发信息，例如：”请在这些坐标显示鼠标轨迹“等等。 如果只有一台计算机，那么可以在同一台计算机上运行 X server 和 X client，当有多台计算机的时候，可以在一台计算机上运行 X 应用程序，通过网络传递信息，在另一台计算机上接收信息，并由 X server 处理，由本机 X client 显示。例如 Exceed、telnet、teamviewer 等远程 X window软件。 严格地说，X 并不是一个软件，它更类似于 HTTP 协议、IP 协议，一个基于 X 的应用程序需要运行并显示内容的时候，就连接到 X 服务器，用 X 协议和服务器交谈，X 服务器提供一些接口供客户使用。同时，X 服务器还负责捕捉键盘和鼠标的动作，并通知 X 程序。 我们打开 Ubuntu 16 系统，看到的桌面系统默认为 Unity 7。常用的桌面系统还有 KDE、Gnome、xfce等。这些桌面系统都集成了 X Windows，它们与基本系统的耦合度都很低，这种低耦合的优点在于，当图形界面出问题的时候，可以进入命令行模式（ctrl+alt+F1-F6）进行修复。 Linux 图形界面层次关系如下： Linux kernel --> X server &lt;-- X 协议 --> 桌面环境 --> X 应用程序。 Shellshell 是命令解释器，它解释由用户输入的命令并把它们送到内核，是用户使用 Linux 的桥梁。用户通过 shell 同 kernel 交互，shell 就像是包裹在 kernel 外面的一层蛋壳，故名 shell。有很多人用不同的方式编写实现了这种命令解释器，shell 是这些软件的统称，它是独立于 Linux kernel 的一种软件，一般的 Linux 发行版都使用 Bash 解释器。 shell 软件虽然有很多种，但是它们都是使用文本指令，而且这些文本指令都是一样的。不管使用的什么发行版的系统，使用的什么类型的图形界面，文本指令都是统一的，用户可以很方便地在不同的发行版间切换，另外，文字指令在远程联机的时候有无可比拟的速度优势。因此，牢记一些常用的 shell 指令是很有必要的。 常用的 Bash 命令Bash 是一个为 GNU 计划编写的 Unix shell，是在 Bourne shell(史蒂夫·伯恩于1978年编写)的基础上编写的，全称为 Bourne-Again shell(这是一个双关语 Bourne again/born again)。 文件与目录前面提过，Unix/Linux 的设计思想是：一切皆文件。Linux 内的所有的一切都是以字节流的形式来呈现的，包括进程、线程、套接字、IO设备等等。所以整个 Linux 系统最重要的地方就是目录树结构。所谓的目录树结构就是以根目录为主，向下呈现分支状的目录结构。整个目录树最重要的就是根目录（root directory，表示方法为 “/“）。目录树结构如下图所示： 目录中不同的路径可以存储在不同的分区，这在 Linux 中叫做挂载，必须将文件所在的分区挂载到一个已存在的目录上，才能通过访问这个目录来访问存储设备。例如，根目录放在磁盘分区1，etc、lib 存储在磁盘分区2，就说分区1是挂载到根目录的，分区2是挂载到etc、lib的。 打开 shell 程序之后，我们看到如图所示： reeves 是当前用户名，rebuntu 是计算机名称，”~”表示当前所处的位置，命令 pwd 可以让我们查看当前所处位置的绝对路径：/home/reeves，第一个”/“不是分隔符，而是根目录，第二个”/“是一个分隔符，/home/reeves == ~，”~”有时候也被称为用户的主目录。 命令 ls，可以让我们查看当前路径下都有什么： ls 是 list 的缩写，列出当前路径下的文件，是 Linux 中最常用的一个命令。打开文件管理器可以看到显示的就是 Home 路径。 ls 命令后面可以加参数与选项，常用的有： -a ：列出全部文件，包括隐藏文件（名字开头为 . 的文件） -l ：列出文件的信息，包含文件的属性与访问权限。显示结果共有 10 列：第1列表明文件类型，其中-代表普通文件，d代表目录文件，c代表字符设备文件，s代表套接字文件，l代表链接文件，p代表管理文件；234列表明文件所有者的读(r)写(w)和执行(x)权限；567列表明文件的组用户权限(组中除所有者外其他人)；8-10列表明其他用户的权限。 执行命令 ls -a，我们发现有两个很特殊的目录，”.” 和 “..” ，在 Linux 中，”.” 是指当前目录，而 “..” 是指上一级目录，命令 cd .. 即可返回上一级目录。 cd 是 Linux 系统中另外一个常用的命令，是 change directory 更换目录的缩写，直接执行 cd 而不加路径的话会默认跳转至用户主目录。cd .. 会返回上一级目录，cd - 则会跳转到上一次访问的路径。 mkdir 命令可以创建新的文件夹，但是文件夹必须一层一层的一次创建，例如，要创建路径： /home/reeves/WorkSpace/pySpacce/test，必须先在路径 /home/reeves 下创建 WorkSpace，然后进入 WorkSpace 中创建 pySpace，再进入 pySpace 创建 test。加上 -p 选项则可以自动依序创建目录。 touch 命令有两个作用，一是创建新的空白文件，二是将已存在的文件的时间标签修改为当前时间（或指定时间）。第一个作用是 touch 命令通常用途。第二个作用在大型项目的编译时会用到。 1$touch hello.txt Ubuntu 自带的程序 gedit 可以打开 hello.txt 文档，并编辑内容。在命令行查看文件内容可以用 cat 命令： 1$cat hello.txt Linux 源码中的 workqueue.c 文件，有5800多行，直接 cat workqueue.c 会显示所有的内容，一屏显示不下，这时候要想查看文件开头几行，可以用 head 命令： 1$head workqueue.c 默认显示文件的前十行文件，要查看指定几行，可以用参数 -n： 1$head -n 20 workqueue.c 要查看文件的后几行，可以使用 tail 命令： 1$tail workqueue.c 依然默认显示10行内容，同 head 命令一样，-n 选项可以指定查看的行数。 tail 命令有一个很实用的用法，-f 选项可以监视文件尾部内容的改动，ctrl+c 可以退出监控。 rm 命令（remove）的作用是删除文件，是一个十分常用但是非常危险的命令。 三个重要的选项与参数： -f ：就是 force 的意思，强制执行，不会出现警告信息； -i ：互动模式，在删除之前会询问使用者是否确定删除； -r ：递归删除，常用于删除目录，是一个非常危险的选项。 1$rm -rf * # 删除当前目录下的一切文件，且不会有任何询问 可执行文件：创建 welcome.c，编译生成可执行文件 welcom，linux 下可执行文件跟 Windows 下的 exe 扩展名不一样，Linux 文件是否可以执行，可以通过 ls -l 查看文件属性列表中是否有 x。执行文件的方法为： 12$gcc welcome.c -o welcome # 编译生成可执行文件$./welcome # '.'表示当前目录，'./'表示当前目录下的可执行文件 权限chmod 命令可以改变文件的权限： 1$chmod 777 test # 执行命令 ls -l test，显示结果为 -rwxrwxrwx 文本编辑vi/vim 是一个文本编辑器，类 Unix 系统都会内置 vi 编辑器，vim 是 vi 的升级版本，两者的用法是一样的。 vim 一共有 3 个模式：正常模式，编辑模式，命令模式。 正常模式一般用于浏览文本，使用命令 vim a.c 即可打开文本，在这个模式中，键盘操作都不会键入相应的字符，而是执行相应的功能： 上下左右键和 hjkl 键可以调整光标的位置。 ctrl+f 向下翻一页 ctrl+b 向上翻一页 dd 删除光标所在行 yy 复制光标所在行 p 粘贴 u 撤销上一次操作 v 可视化选择，可以通过上下左右键来扩大选中范围 gU 选中部分变大写 gu 选中部分变小写 gg 跳转到文件首行 G 跳转到文件末尾 数字加gg 跳转到指定行 i 进入编辑模式(insert 模式)，按 Esc 退出编辑模式。 ctrl+s 锁定窗口，什么操作都不会有响应 ctrl+q 解锁窗口 编辑模式中键盘操作均作为键盘输入，要移动光标只能用上下左右键操作： Esc 退出编辑模式。 如果在退出之前希望保存所作的修改，那么需要进入命令模式。按”:”或者”/“即可进入。 :w 保存 :q 退出vim :wq 保存并退出 :q! 取消修改并退出 :set nu 显示文件的行号 :set nonu 取消行号显示 :sp 把当前窗口水平分割成两个窗口，后面可以加文件名 sp filename，ctrl+w+j/k上下屏切换 :vsp 把当前窗口竖直分割成两个窗口，后面可以加文件名 vsp filename，ctrl+w+h/l左右屏切换 /someword 匹配输入的someword，n：向后查找下一个，N：向前查找下一个 磁盘df 命令是列出文件系统的整体磁盘空间使用情况。 参数： -h : 以人们易读的GB、MB、KB等格式显示。 -m：以MB为单位展示。 -k：以KB为单位展示。 du 命令是查看当前指定文件或目录占用的磁盘空间大小。 参数： -h：以KB，MB，GB等格式显示。 -s：只显示总计。 -m：以MB为单位展示。 -k：以KB为单位展示。 压缩和打包Linux 环境中，压缩文件的扩展名大多是：.tar, .tar.gz, .tgz, .gz, .Z, .bz2。 *.Z compress 程序压缩的文件 *.gz gzip 程序压缩的文件 *.bz2 bzip2程序压缩的文件 *.tar tar程序打包的文件，没有经过压缩 *.tar.gz tar程序打包的文件，并经过gzip压缩 *.tar.bz2 tar程序打包的文件，并经过bzip2压缩 目前主流的压缩技术只有 gzip 和 bzip2，compress 基本上已经被取代，bzip2 理论上是最新最好的压缩方法。 gzip 是应用最广的压缩指令。所生成的压缩文件扩展为 *.gz，压缩和解压指令为： 12$gzip hello.c$gzip -d hello.c.gz -d 是 decompress的意思。 bzip2 可以提供更好的压缩率，生成的文件扩展为 *.bz2。压缩和解压指令为： 12$bzip2 hello.c$bzip2 -d hello.c.bz2 压缩命令只能压缩单个文件，不能压缩目录，如果要压缩目录，需要用到 tar 打包命令。 选项与参数： -c：打包目录 -x：解包目录 -z：用 gzip 压缩/解压 -j：用 bzip2 压缩/解压 -f：要处理的文件名。压缩的时候要指明压缩后的名称和要处理的目录名 -v：处理过程中显示正在处理的文件。 在 Linux 中遇到打包压缩的文件，可以根据后缀名选择相应的命令。 软件下载和安装apt (advanced packaging tool)是 Linux 下的一款安装包管理工具。常用的命令如下： apt update 从软件源服务器获取最新的软件信息并缓存到本地 apt upgrade 从本地仓库中对比系统中所有已安装的软件，如果有新版本的话进行升级 apt list 列出本地仓库中所有的软件包名 apt install 安装指定的包 apt remove 卸载指定的包，但不删除相关配置文件 apt purge 卸载指定的包，同时删除相关配置文件 apt autoremove 卸载目前不再依赖的孤立的包 dpkg (Debian packager)命令可以用来安装、删除 Debian 的软件包。与apt 不同的是，dpkg 指定的软件必须是已经下载到本地的 *.deb 文件。 常用命令如下： dpkg -i 安装指定软件 dpkg -r 删除软件包，保留其配置 dpkg -P 移除软件，不保留配置 Bash &amp;&amp; Shell数据流重定向和管道命令数据流重定向就是将本该在屏幕上出现的内容重定向到一个文件中。具体的做法就是在命令之后添加”&gt;”或者”&gt;&gt;”，其中”&gt;”的意思是将左侧命令产生的输出写入右侧文件中去，写入是以覆盖的方式进行的。”&gt;&gt;”的意思是将左侧命令产生的输出写入右侧文件中去，写入是以累加的方式进行的。12$ls &gt; result.txt # 将 ls 的结果写入到 result.txt 中去$cat &gt; hello.txt # 支持键盘输入内容到 hello.txt 文件中去 ；&amp;&amp; || 很多时候，我们想要一次输入多个命令时，可以用 ： cmd1; cmd2; … cmd1和cmd2直接没有相关性 cmd1 &amp;&amp; cmd2 cmd1运行完毕且正确则运行cmd2，否则不运行 cmd1 || cmd2 若cmd1运行完毕且正确，则cmd2不运行。否则cmd2运行 管道命令 管道命令的符号是 |，cmd1 | cmd2。即用 cmd2 来处理 cmd1 产生的结果。 统计目录下的文件数量：1$ls | wc -l 显示文件名中包含“text”的文件：1$ls | grep "text" bashrc/etc/profile 文件是一个系统级的 profile 文件。因为 Linux 是一个多用户的系统，允许每一个用户有不同的配置文件，但是每一个使用系统的用户都会先载入 /etc/profile 的配置。这个脚本会读取 /etc/profile.d/*.sh ，这里面有一些 bash 程序的配置，命令的别名等等。 bash 在载入了整体环境配置之后再依序载入 ~/.profile 文件和 ~/.bashrc 文件。 一般对于个人用户，要想添加可执行程序的路径，或者定义 bash 命令就要修改 ~/.bashrc 文件。 linux 常用软件安装与强化学习环境配置汉语输入法首先安装汉语语言包： 1$sudo apt install language-pack-zh-hans 安装谷歌拼音输入法。执行这个命令，系统会自动安装 fcitx，googlepinyin，以及一些 fcitx 配置程序： 1$sudo apt install fcitx-googlepinyin 打开 systemsettings -&gt; Language Support，系统会自动进行语言包搜索，按照系统提示确认安装。fcitx 是一个输入法框架。如图所示，在 Keyboard input method system 中选择 fcitx： 重启电脑，fcitx 输入法框架开始运行。在终端执行 fcitx-configtool，进行输入法配置。点击 “+” 添加Google Pinyin： 若列表里没有 Google Pinyin，需要取消 Only Show Current Language 复选框： 添加完输入法之后，在 Global Config 中可以看到输入法的切换方式： 以上。 Nvidia 驱动安装在 All Settings -&gt; Details 中查看自己的设备信息，如图： Nvidia 驱动和 CUDA 版本存在着对应关系，可以在官网查看。 这里可以查看 GPU 支持的驱动版本。 推荐使用 ppa 源安装驱动，方法如下： 首先添加 ppa 源，执行如下语句： 1$sudo add-apt-repository ppa:graphics-drivers/ppa 获取最新的软件包源，将其添加至当前 apt 库中，执行后会显示当前可供下载的最新驱动版本号，已经老的驱动版本号。如图： 最新的版本为 nvidia-410(410.66)，稍早的版本为 nvidia-390(390.87)。更新软件库信息，并下载 Nvidia 驱动： 12$sudo apt update$sudo apt install nvidia-390 安装三维图像库和 OpenGL 环境，并重启： 123$sudo apt install mesa-common-dev$sudo apt install freeglut3-dev$sudo reboot 在终端输入 nvidia-smi，若输出如下，则说明安装成功： All Setting -&gt; Details 内显示 Graphics 为 Geforce 920： 在 .bashrc 中添加路径：1$export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/nvidia-390 以上。 CUDA 安装以 cuda8 为例，参考博客。 很多博客都指出要先禁用 nouveau 服务，并加入黑名单，这个步骤很麻烦，同时也是没有必要的。首先，我们来看 nouveau 是什么。nouveau 是一个开源驱动项目，是 Linux KMS（kernel mode-setting）驱动的一部分，是一个公版的显卡驱动程序，可以驱动 AMD、高通的芯片，nvidia 也参与了开发，KMS 项目是为了在文本系统Linux中显示图形界面而诞生的开源项目。也就是说，这个 nouveau 和我们安装的 nvidia 驱动是冲突的，所以是要禁止掉的。但是，如果我们已经通过 ppa 安装好了 nvidia 显卡驱动，那么再处理这个公版驱动就没有必要了。CUDA 安装指南Installation Guide for Linux 中指明了需要 Disable the Nouveau drivers，但是在具体如何禁用的时候，文档又指出了: The Nouveau drivers are loaded if the following command prints anything: 1$lsmod | grep nouveau 如果执行命令后什么也没有显示，则说明 Nouveau drivers 本身就没有被使用，所以是不用禁用的。 直接执行如下命令： 1$sudo sh cuda_8.0.61_375.26_linux.run 或者 1$sudo sh cuda_8.0.61_375.26_linux.run --no-opengl-libs # 更推荐这种方式 按照提示一步步安装即可，注意安装驱动的选项要选择 no。 然后安装补丁 Patch 2： 1$sudo sh cuda_8.0.61.2_linux.run 安装完成后，在环境变量中添加 CUDA，在 .bashrc 中添加： 12export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$LD_LIBRARY_PATH 重启电脑，即完成 CUDA 安装。 以上。 CUDNN 安装cudnn 需要注册 nvidia 账号才可以下载。共有三个文件： libcudnn6-dev_6.0.21-1+cuda8.0_amd64.deb libcudnn6_6.0.21-1+cuda8.0_amd64.deb libcudnn6-doc_6.0.21-1+cuda8.0_amd64.deb 命令行执行： 123$sudo dpkg -i libcudnn6-dev_6.0.21-1+cuda8.0_amd64.deb$sudo dpkg -i libcudnn6_6.0.21-1+cuda8.0_amd64.deb$sudo dpkg -i libcudnn6-doc_6.0.21-1+cuda8.0_amd64.deb 安装完毕后重启终端。 输入命令： 1$nvcc -V 会显示 CUDA 的版本号。 进入 ~/NVIDIA_CUDA-8.0_Sample/1_Utilities/deviceQuery/，执行 make 命令： 12$make$./deviceQuery 显示 Result = PASS。CUDA+CUDNN 安装成功。以上。 tensorflow 安装使用 pip 安装即可。首先，在 anaconda 中创建虚拟环境：1$conda create -n tf python=3.5 这里最好创建 python3.5 的环境，因为后面安装的包对更高版本的支持不是太好。tensorflow 的向下兼容性并不是很好，这里要选择好tensorflow的版本，tensorflow 和 CUDA 以及 cudnn 的版本对应关系如下，数据来自博客 tensorflow-gpu cuda cudnn python v1.9.0 9.0 7.1.4 2.7,3.3-3.6 v1.8.0 9.0 7 2.7,3.3-3.6 v1.7.0 9.0 7 2.7,3.3-3.6 v1.6.0 9.0 7 2.7,3.3-3.6 v1.5.0 9.0 7 2.7,3.3-3.6 v1.4.0 8.0 6.0 2.7,3.3-3.6 v1.3.0 8.0 6.0 2.7,3.3-3.6 v1.2.0 8.0 5.1 2.7,3.3-3.6 v1.1.0 8.0 5.1 2.7,3.3-3.6 根据之前安装的cuda和cudnn，我选择安装 tensorflow v1.4.0:12$source activate tf # 进入虚拟环境 tf$pip install tensorflow-gpu==1.4.0 # 若提示有包依赖，再安装便是 以上。 mujoco安装破解版的三个文件：mjkey.txt, mjpro150, mjpro150_linux.zip。 首先，在主目录下创建隐藏文件夹 mujoco，并将压缩包 mjpro150_linux.zip 解压到这里：1234$mkdir ~/.mujoco$cp mjpro150_linux.zip ~/.mujoco$cd ~/.mujoco$unzip mjpro150_linux.zip 然后，将 mjket.txt 复制到 ~/.mujoco 和 ~/.mujoco/mjpro150/bin :12$cp mjkey.txt ~/.mujoco$cp mjkey.txt ~/.mujoco/mjpro150/bin 复制 mjpro150 到 .mujoco 中，覆盖原有的 mjpro150 文件夹：1$cp -rf mjpro150 ~/.mujoco 修改文件执行权限：1$sudo chmod 777 -R .mujoco 然后添加环境变量，在 .bashrc 中添加：12export LD_LIBRARY_PATH=~/.mujoco/mjpro150/bin$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;export MUJOCO_KEY_PATH=~/.mujoco$&#123;MUJOCO_KEY_PATH&#125; 运行测试：12$cd ~/.mujoco/mjpro150/bin$./simulate ../model/humanoid.xml 以上。 mujoco_py 安装：首先，在 github 上下载源码：1$git clone https://github.com/openai/mujoco-py.git 下载下来的代码中包含 requirements.txt，需要先安装里面的依赖包：1$pip install -r requirements.txt 安装完依赖之后安装 mujoco_py：1$pip install -u 'mujoco-py&lt;1.50.2,&gt;=1.50.1' 安装过程中如果 gcc 报错，那么执行以下语句：1$sudo apt install libgl1-mesa-dev libgl1-mesa-glx libosmesa6-dev python3-pip python3-numpy python3-scipy 若出现错误：fatal error:GL/glew.g：没有那个文件或目录，解决方法：1sudo apt install libglew-dbg libglew-dev libglew1.10 libglew-dbg libglewmx-dev libglewmx1.13 glew-utils 安装完毕后，测试安装结果。1$cp -rf ~/Downloads/mujoco-py/xmls ~/.local/lib/python3.5/site-packages 然后执行 python 代码：12345678910import mujoco_pyfrom os.path import dirnamemodel = mujoco_py.load_model_from_path(dirname(dirname(mujoco_py.__file__))+"/xmls/claw.xml")sim = mujoco_py.MjSim(model)print(sim.data.qpos) # [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]sim.step()print(sim.data.qpos)# [2.09217903e‐06 ‐1.82329050e‐12 ‐1.16711384e‐07 ‐4.69613872e‐11# ‐1.43931860e‐05 4.73350204e‐10 ‐3.23749942e‐05 ‐1.19854057e‐13# ‐2.39251380e‐08 ‐4.46750545e‐07 1.78771599e‐09 ‐1.04232280e‐08] 以上。 安装 gym使用源码安装：1234$git clone https://github.com/openai/gym.git$cd gym$sudo apt install -y python-numpy python-dev cmake zlib1g-dev libjpeg-dev xvfb libav-tools xorg-dev python-opengl libboost-all-dev libsdl2-dev swig$pip install -e .[all] 运行测试程序：123456789101112import gymenv = gym.make('Hero-ram-v0')for i_episode in range(20): observation = env.reset() for t in range(100): env.render() print(observation) action = env.action_space.sample() observation,reward,done,info = env.step(action) if done: print("Episode finished after &#123;&#125; timesteps".format(t+1)) break 补充，安装需要依赖 cmake 和 zliblg-dev，1$sudo apt install cmake libz-dev 以上。 baseline 的安装baseline 需要 python3.5 及其以上的版本。安装依赖：1$sudo apt install libopenmpi-dev baseline 安装方法如下：123$git clone https://github.com/openai/baseline.git$cd baseline$pip install -e . 若出现错误 ERROR: GLEW initalization error: Missing GL version 解决办法为，在 .bashrc 中添加：1$export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libGLEW.so:/usr/lib/nvidia-390/libGL.so 若出现错误 AssertionError: TensorFlow needed, of version above 1.4 解决办法为：1$sudo ldconfig /usr/local/cuda/lib64/ 测试安装结果：12$cd ~/baseline/baseline/her/experiment/$python train.py --num_cpu=2 训练完毕后调用：1$python play.py /tmp/openai-2019-01-04-13-26-30-141299/policy_best.pkl # 后面这个参数是训练结束后输出的值 以上。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++ 读书笔记 03：尽可能使用const]]></title>
    <url>%2FNotes%2F2019%2F01%2F22%2FEffective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[const 允许你指定一个语义约束，而编译器会强制执行这项约束，确保某个对象不会被改变。如果某个对象在执行中不应该（或者不会）被改变，就应该使用const。 一. const 修饰变量看下面一段代码： 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; int a = 1; //non-const data const int b = a; //const data int *c = &amp;a; //non-const data,non-const pointer const int *d = &amp;a; //const data,non-const pointer int * const e = &amp;a; //non-const data,const pointer const int * const f = &amp;a; //const data,const pointer const int * const g = &amp;a; //const data,const pointer return 0;&#125; const 修饰指针的时候，const 在 * 号右边表示指针是 const 的，在 * 左边，表示 *p（即指针指向的对象），是 const 的。在 STL 迭代器的应用中，map&lt;int, int&gt;::const_iterator itr 相当于 const T* itr，即迭代器（指针）itr 指向的对象 *itr 是 const 的，而 const map&lt;int, int&gt;::iterator itr 相当于 T* const itr，即迭代器 itr 是 const 的。 在上边代码中，若 a 的值被改变了，那么除 b 外，*c， *d， *e， *f， *g 都会改变，因为 b 的赋值是 copy 赋值立即数，之后的 b 就跟 a 没有关系了，但对 c-g 而言，修饰它们的 const 仅仅表示，不能修改指针的值或者通过 *p 修改指针指向的变量，但 a 并不是 const data，所以可以通过修改 a 的值来改变指针 cdefg 指向的值。 使用 const 需要注意，const 对象必须初始化（因为它不能改变不能接受再次的赋值）（但并不一定在声明的同时给予初值）。在函数中声明 const 需要立即给初值，在类 class 中声明的时候，不能立即赋值，这是因为 const 数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的（这点与 static 相反），类可以创建多个对象，相应的 const 成员的初始化只能在类的构造函数的初始化表中进行： 1234567class Stuff &#123;public: Stuff(int m) : max_num(m) &#123; &#125;;private: const int max_num;&#125;; 要想建立在整个类中都恒定的常量，应该用类中的枚举常量或者 static 来实现。 二. const 修饰成员函数const 成员函数的声明：const 关键字只能放在函数声明的尾部！ 123int func() const &#123; return 0;&#125; const 修饰的成员函数不能修改这个类对象的任何的数据成员（准确地说是非静态数据成员）。 const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可以会修改成员变量。 在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要声明为const 成员函数。有 const 修饰的成员函数（const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。 这样做好处在于，首先，类的接口更容易被理解，一看便知函数是读操作还是有写操作；其次，将成员函数声明为 const 使得该函数操作 const 对象成为可能，因为常量（即 const）对象可以调用 const 成员函数，而不能调用非 const 修饰的函数。 ps：之所以我们希望函数可以操作 const 对象是因为处于程序的效率考虑，传引用或者指针往往比传值要好，传引用的时候为了防止对象被修改，往往要声明为 const 引用或指针，const 对象不能调用非 const 函数，所以，尽可能的将只有读操作的函数声明为 const 函数。 注意：两个成员函数如果只是常量性不同，是可以被重载的，原因在于函数的形参列表里隐藏有 this 指针，const 函数里 this 指针是指向 const 对象的指针，而非 const 函数里的 this 指针是正常版本的指针。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;class Chinese &#123;public: Chinese() &#123; personID = IdentityCardId; IdentityCardId++; &#125; int getNation() const&#123; cout &lt;&lt; "CHINA ID : " &lt;&lt; personID &lt;&lt; endl; IdentityCardId++; return 0; &#125; int getNation() &#123; cout &lt;&lt; "china ID : " &lt;&lt; personID &lt;&lt; endl; return 0; &#125;private: static int IdentityCardId; int personID;&#125;;int Chinese::IdentityCardId = 1;int main() &#123; const Chinese LaoWang = Chinese(); LaoWang.getNation(); //输出CHINA ID:1，const对象LaoWang默认调用const成员函数，并且可以修改static变量IdentityCardId Chinese LaoSun = Chinese(); LaoSun.getNation(); //输出china ID:3，non_const对象LaoSun默认调用non_const的成员函数 return 0;&#125; const 对象默认调用 const 成员函数，非 const 默认调用 const 成员函数，类中只有一个函数存在的情况下（我们删掉 non_const 版本的 getNation()），non_const 的对象也可以调用非 const 成员函数。 三. const 修饰函数返回值如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加 const 修饰的同类型指针。例如函数: 1const char * GetString(void); 如下语句将出现编译错误： 1char *str = GetString(); 正确的用法是: 1const char *str = GetString(); 如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加 const 修饰没有任何意义。 例如不要把函数: 1int GetCnt(); 写成: 1const int GetCnt(); 同理不要把函数(T为自定义数据类型): 1T getT(void); 写成 1const T getT(void); 如果返回值不是内部数据类型，将函数 T getT(void) 改写为 const T &amp; getT(void) 的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。 函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。（除了重载操作符外一般不要将返回值类型定为对某个对象的 const 引用！） 例如： 1234567class A &#123; A &amp; operate = (const A &amp;other); // 赋值函数&#125;;A a, b, c; // a, b, c 为A 的对象a = b = c; // 正常的链式赋值(a = b) = c; // 不正常的链式赋值，但合法 如果将赋值函数的返回值加 const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2FNotes%2F2019%2F01%2F20%2Ftest%2F</url>
    <content type="text"><![CDATA[Hello World!Welcome to visit my blog!this my first blog. papers coding books 11 11 1111 123 456 789]]></content>
      <categories>
        <category>测试文档</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FNotes%2F2019%2F01%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试文档</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>文档</tag>
      </tags>
  </entry>
</search>
