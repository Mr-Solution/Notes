<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python-print一个进度条]]></title>
    <url>%2FNotes%2F2019%2F07%2F09%2Fpython-print%E4%B8%80%E4%B8%AA%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[我们都知道print(&#39;\n&#39;)表示换行，转义字符\n对应的意义就是换行，将当前输出位置移到下一行的开头。 为了实现进度条的功能，我们要在print()函数中使用另一个转义符\r。\r的意义是回车，将当前输出位置移到当前行的开头。所以我们可以使用print(\r)来使打印内容在同一行循环出现。 但是，我们应该注意到，在使用print()函数的时候，其实不需要参数\n也会输出换行。这是因为，print()函数有一个默认参数end=&#39;\n&#39;，如果不显式指明end的值，那么默认输出换行。所以我们要想实现代码在一行循环出现，应该这样写：123for i in range(10): print(u"当前进度为 &#123;&#125;/10".format(i), end='\r') # u表示字符串为unicode字符串，输出中文时防止乱码 time.sleep(0.25） 了解了其中的原理，再写一个进度条就很容易了：12345678import timecount_down = 10 # 倒计时时间，单位：秒interval = 1 # 屏幕刷新的间隔时间，单位：秒for i in range(0, int(count_down/interval)+1): print("#"*i + " " + "%.2f"%(i/(count_down/interval)*100) + "%", end='\r') # 因为浮点数的除法会出现结果不准确的情况，故使用 %.2f 规则化输出 time.sleep(interval)print("\n加载完毕") 同进度条类似，我们可以实现一个在命令行“转圈”的等待效果：1234567891011import timecount_down = 10 # 设置倒计时时间，单位：秒interval = 0.25 # 设置屏幕刷新的间隔时间，单位：秒for i in range(0, int(count_down/interval)): ch_list = ["\\", "|", "/", "-"] index = i % 4 print("\rinstalling " + ch_list[index], end="") time.sleep(interval)print("\rinstallation accomplished.")]]></content>
      <categories>
        <category>Python Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指 offer 读书笔记：编程语言篇]]></title>
    <url>%2FNotes%2F2019%2F06%2F22%2F%E5%89%91%E6%8C%87-offer-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[C/C++ 的字符串、数组、指针、结构体、堆栈、static关键字、const关键字，是非常重要且经常出错的知识点。 C/C++1. 基础知识1.1 C 字符串和 C++ 字符串 C 语言是没有字符串的，C 风格字符串是以一维字符数组的形式存储，并以字符’\0’终止。 C++ 中引入了 string 类，字符串在 C ++ 中用一个 string 实例表示。 1.2 sizeof()数组12345678#include &lt;stdio.h&gt;int main() &#123; char *p = "abcdef"; char a[] = "abcdef"; printf("sizeof(p) = %lu\n", sizeof(p)); printf("sizeof(a) = %lu\n", sizeof(a)); return 0;&#125; 输出sizeof(p) = 8，sizeof(a) = 7。sizof(p)输出的是指针 p 的大小，指针的大小同系统的寻址能力有关，在64位系统中，一个指针为64位，等于8字节，所以 sizeof(p)=8。a 是一个数组名，编译器用数组名来记录数组的属性，比如数组的大小等。数组名只有在表达式中使用时，编译器才会为它产生一个指针常量，但是有两个例外——sizeof 操作符和单目操作符 &amp;。sizeof返回整个数组的长度，而不是指向数组的指针的长度。取一个数组名的地址产生的是一个指向数组的指针，而不是指向某个指针常量值的指针。一定要记住：数组名并不等价于指针。 · 问：sizeof 是如何知道数组大小的？· 答：sizeof(arr)不是程序执行到这里的时候才去求值的，并且sizeof(arr)计算的是数组所占字节数，并非数组长度，数组长度 = sizeof(arr)/sizeof(类型)。例如，定义一个数组 arr，int arr[10]，那么sizeof(arr)的结果为 40，而sizeof(arr)/sizeof(int)的结果为 10。sizeof关键字是在编译阶段处理的，在程序运行之前，sizeof(arr)的结果就已经被计算好并保存在.out文件中。 结构体结构体的地址对齐有两条原则： 结构体中成员的偏移量必须是成员大小的整数倍； 结构体大小必须是所有成员大小的整数倍，即所有成员大小的公倍数。 1234567891011typedef struct &#123; char c; int i;&#125; S1;typedef struct &#123; char c1; S1 s1;&#125; S2;...printf("sizeof(S1) = %lu\n", sizeof(S1));printf("sizeof(S2) = %lu\n", sizeof(S2)); 运行结果为：sizeof(S1) = 8，sizeof(S2) = 12。char 占 1 个字节，int 占 4 个字节，在对齐的时候，c 的偏移量为 0，i 的偏移量为 4，S1 的大小为 8。对于嵌套的结构体 S2，需要将其展开。两条原则变为： 展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。 结构体大小必须是所有成员(展开后的成员)大小的整数倍。 这里 S1 中最大的类型为 int，占4字节，所以，s1.c 的偏移量为4，s1.i 的偏移量为8，S2 的大小为12。 对空的结构体求 sizeof，结果与编译器有关，clang 和 gcc 均返回0。结构体的对齐方式还会收到预编译指令#pragma pack()的影响，具体内容看 2.1 节。 1.3 strlen()表面上看，strlen和sizeof都可以求字符串的长度，但二者却存在着本质的区别。 sizeof是一个运算符，strlen是一个函数。 sizeof返回操作对象所占的内存字节数；strlen返回字符串的长度(字符的个数，并不等于内存字节数)，不包括结束字符(‘\0’ )。 sizeof的结果在编译阶段生成；strlen的结果在运行阶段产生。 123char str[] = "abc";printf("sizeof(str) = %lu\n", sizeof(str));printf("strlen(str) = %lu\n", strlen(str)); 输出分别为4和3。 1.4 C++中字符数组和指针的区别参考博客。 第一个例子：123char str1[] = "abc";char str2[] = "abc";printf("%d\n", str1 == str2); 这段代码最终会输出结果 0。因为，”abc”是一个常量，保存在常量存储区，str1 是一个数组变量，保存在栈区，语句char str1[] = &quot;abc&quot;的意思是，在栈区申请大小为 4 的空间，保存”abc”(字符数组结尾默认添加’\0’)。同理，char str2[] = &quot;abc&quot;也申请了一块栈区的内存。即 str1 和 str2 存放在不同的位置，在表达式str1 == str2中，str1 和 str2 都是指针，分布指向两个数组的起始地址，故 str1 == str2 会返回 false。在使用 clang 编译代码的时候，编译器会提示： warning: array comparison always evaluates to false 就是告诉用户，数组内容虽然一样，但是数组名作为指针，指向的是不同的内存区域。gcc 则缺少相应的提示。 第二个例子：1234567const char *str3 = "abc";const char *str4 = "abc";printf("%d\n", str3 == str4);const char str5[] = "abc";const char str6[] = "abc";printf("%d\n", str5 == str6); 第一个printf会输出1，第二个printf会输出0。这是因为，使用const定义的变量一般是不分配内存，而是保存在符号表中的，即指针 str3 和 str4 都是保存在符号表上，指向常量存储区中的常量”abc”，所以 str3 == str4。但是，对于 const 数组来说，因为系统不确定符号表是否有足够的空间来存放数组，所以还是会在栈区分配内存，所以 str3 指向的是栈区的”abc”，str3 不等于 str4。 1.5 const1.6 static2. 内存管理2.1 struct 对齐2.2 堆和栈new&amp;delete3. 常见的一些函数3.1 gets()3.2 strcpy()3.3 malloc() &amp; free()3.4 new() &amp; delete()Q&amp;A SUMMARIZE Q：对一个空的类型求 sizeof，得到的结果是多少？A：1。空类型的实例中不包含任何信息，本来求 sizeof 是 0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。具体占用多少内存，由编译器决定。A：0。gcc 和 clang 的编译结果都是 0。 Q：如果在空类型中添加一个构造函数和析构函数，再求 sizeof，结果是多少？A：1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数而在实例内添加任何额外的信息。Q：如果把析构函数标记为虚函数呢？A：C++ 编译器发现类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，一个指针占 4 字节，求 sizeof 结果为 4。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三门问题]]></title>
    <url>%2FNotes%2F2019%2F06%2F19%2F%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Redis 学习笔记]]></title>
    <url>%2FNotes%2F2019%2F06%2F14%2FRedis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Redis 学习笔记，不定期更新。 书籍及源码书籍： 《Redis设计与实现》 代码： Redis 源码 《Redis设计与实现》Redis源码注释 如何阅读 Redis 源码]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳表]]></title>
    <url>%2FNotes%2F2019%2F06%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[跳表是一个比较冷门的数据结构，很多数据结构的书里都不会讲它。但跳表确实是一个很优秀的数据结构，并且经常在面试中被问到，所以我们很有必要了解一下这个数据结构。 本文的主要内容搬运自极客时间专栏。极客时间版权所有: https://time.geekbang.org/column/article/42896 更多关于跳表的内容可以查阅《Redis设计与实现》。 什么是跳表我们都知道二分查找算法，它依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？实际上，我们只需要对链表稍加改造，就可以支持类似“二分”查找算法。我们把改造之后的数据结构叫作跳表（Skip list）。 跳表是一个各方面性能都比较优秀的动态数据结构，支持快速的插入、删除、查找操作，在一些地方甚至可以替代红黑树。比如 Redis 中的有序集合（Sorted Set）就是用跳表来实现的。 对于一个单链表，即便其中存储的数据是有序的，如果我们想在其中查找某个数据，也只能从头到尾遍历链表。这样的查找时间复杂度是O(n)，效率比较低。 那怎么来提高查找效率呢？可以如下图所示，对链表建立一级“索引”，查找的时候先遍历索引，然后通过索引层的指针找到原始链表，继续查找。 比如要查找16，我们可以现在索引层遍历，当遍历到节点13时，我们发现下一个节点值为17，那么16一定位于这两个节点之间。然后我们通过索引层节点13的 down 指针，下降到原始链表这一层，继续遍历。这种方式查找到16只需要遍历7个节点（1，4，7，9，13，13，16），而直接遍历原始链接则需要遍历16个节点。查找效率得到了提升。 在此基础上，再加一层索引，在第一级索引中抽取节点组成二级索引。如下图所示： 再来查找16，只需要遍历6个节点（1，7，13，13，13，16），再次提升了速度。当数据量很大的时候，这里的效率提升会更加明显。 总结一下：这种链表加多级索引的结构，就是跳表。 跳表的速度先说结论：跳表查找的时间复杂度为 O(logn)。对比单链表查找的时间复杂度为 O(n)，跳表确实提高了查找的效率。 对于一个有 n 个节点的链表，假设每 m 个节点生成一个索引节点，最高层索引有两个节点，那么索引的层数 h = logmn，查找到一个点的时间复杂度就为 O(m*logmn)。通常取 m = 2，时间复杂度为 O(logn)。 根据等比数列的求和，跳表的空间复杂度为 O(n)。在实际的软件开发中，原始链接中存储的节点有可能是很大的数据结构，而索引节点中只用存储关键值和指针，索引占用的额外空间远小于原链表。 跳表索引的动态更新当不停地往跳表中插入数据时，如果不及时更新索引，就有可能出现两个索引节点之间数据非常多的情况。极端情况下，跳表会退化成单链表。 红黑树、AVL树这样的平衡树时通过左右旋的方式保持子树的平衡。而跳表是通过随机函数来维护“平衡”。当我们往跳表内插入数据时，我们可以同时将这些数据插入到部分索引层。至于插入到哪几级索引层，是通过一个随机函数来确定的。比如随机函数生成了数值 K，那么就将这个节点添加到第一级到第 K 级索引中。 随机函数的选择可以参考Github 上这段代码或者 Redis 中关于有序集合的跳表实现（zslRandomLevel(void)）。 以上。]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[On-Policy & Off-Policy]]></title>
    <url>%2FNotes%2F2019%2F06%2F11%2FOn-Policy-Off-Policy%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[python 模块、包及 import 方法]]></title>
    <url>%2FNotes%2F2019%2F06%2F11%2Fpython-%E5%8C%85-%E6%A8%A1%E5%9D%97-%E5%8F%8Aimport%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模块通过使用命名空间提供了将部件组织为系统的简单的方法。在一个模块文件的顶层定义的所有的变量名都成了被导入的模块对象的属性。在模块导入时，模块文件的全局作用域变成了模块对象的命名空间。Python 的模块允许将独立的文件连接成一个更大的程序系统。 模块和包在 Python 中，一个 .py 文件就是一个模块（module）。使用模块大大提高了代码的可维护性，一个模块编写完成，就可以被其他项目代码引用。使用模块还可以避免函数名和变量名的冲突，相同名字的函数和变量可以分别存在于不同的模块中。我们在编写自己的模块时，不必考虑名字与其他模块内名字冲突。 在创建许许多多模块后，我们可能希望将某些功能相近的文件组织在同一文件夹下，这里就需要运用包的概念了。简单的说，包就是一个文件夹，但该文件夹下必须有 __init__.py 文件（若无，则 Python 将其视为一个普通目录）。常见的包结构如下： 1234my_package/ __init__.py a.py b.py 包可以有多级目录，组成多层次的包结构： 12345678my_package/ __init__.py web/ __init__.py www.py utils.py a.py utils.py 文件 www.py 的模块名就是 my_package.web.www，两个utils.py 的模块名分别是 my_package.utils 和 my_package.web.utils。 第一次导入包或者包的任何其他部分，会执行包中的 __init__.py 文件，这个文件可以为空，也可以存放一些初始化的代码。 __init__.py 可以为空，也可以执行包的初始化或者设置 __all__ 变量的值。 导入模块模块是最高级别的程序组织单元，它将程序代码和数据封装起来以便重用。模块可以由两个语句和一个重要的内置函数进行处理。 import: 使导入者以一个整体获取一个模块 from: 允许导入者从一个模块文件中获取特定的变量名 imp.reload: 在不中止 Python 程序的情况下，提供了一种重新载入模块文件代码的方法。 import 后面应该跟模块名，用法为import module或from package import module。在导入自建包的时候，如果直接写import my_package，my_package.my_module.my_func()，会报错module &#39;my_package&#39; has no attribute &#39;my_module&#39;，即 Python 将导入自建包的语句当作是导入一个模块。有一些操作可以让我们实现import my_package这种写法，在下面会做讨论。 首先，我们要先了解一下，当我们在 Python 代码中执行 import 的时候，Python 解释器做了什么。 有些 C 程序设计者喜欢把 Python 的模块导入操作比作 C 语言中的 #include，但其实不应该这么比较：在 Python 中，导入并非只是把一个文件文本插入另一个文件而已。导入其实是运行时的运算，程序第一次导入指定文件时，会执行三个步骤。 找到模块文件。 编译成位码。 执行模块的代码来创建其所定义的对象。 这三个步骤旨在程序执行时，模块第一次导入时才会进行。在这之后，导入相同模块时，会跳过这三个步骤，而只提取内存中已加载的模块对象。更底层一些的说，Python 把载入的模块存储到一个名为 sys.modules 的表中，并在一次导入操作的开始检查该表，如果模块不存在，将会启动一个三步骤的过程： 搜索Python 使用标准模块搜索路径来找出 import 语句所对应的模块文件。在标准的 import 中引入路径从语法上讲是非法的[注]。模块搜索路径包括程序主目录，PYTHONPATH 目录，标准链接库目录以及任何 .pth 文件的内容（按顺序依次搜索）。这四者组合起来就是 sys.path。我们在有的地方看到会 import os，然后再 path 中添加模块所在的路径，就是在操作 sys.path。注：可以使用from dir1.dir2 import module或import dir1.dir2.module，这样加了路径的导入方式，但是前提是，dir1 位于上述四个搜索路径之中。 编译（可选）找到源文件后，Python 会将其编译成字节码，若在搜索路径上只发现了字节码文件，而没有源代码，则会直接加载字节码（这意味着可以把一个程序模块作为字节码发布，使程序提速）。被导入的文件会产生一个 .pyc 字节码文件，被导入文件的字节码保存在文件中从而可以提高之后导入的速度。 执行 模块文件中的所有语句会依次执行，任何对变量名的赋值运算，都会产生所得到的模块文件的属性。 import 和 from客户端可以执行 import 或 from 语句来使用模块文件，如果模块还没被加载，这两个语句就回去搜索、编译以及执行模块文件。主要的差别在于，import 会读取整个模块，from 将获取（或者说复制）模块中特定的变量名。 12345import module1module1.printer('hello world!')from module1 import printerprinter('hello world!') 这段代码展示了两种导入方式。import 语句使用一个变量名引用整个模块对象，所以必须通过模块名称（module1）来使用模块的属性（printer）。from 把模块中的变量名 printer 复制到另一个作用域，它让我们可以直接在脚本中使用复制后的变量名。from语句有破坏命名空间的潜质。如果使用from导入变量，而那些变量碰巧和作用域中现有变量重名，变量就会被悄悄的覆盖掉。使用 import 语句时就不存在这种问题，因为必须通过模块名才能获取其内容。不过，使用from时，只要你了解并预料到可能发生这种事，在实际情况下这就不是一个大问题了，尤其是当你明确列出导入变量名时（例如，from module import x, y, z）。 import 和 from 是赋值语句！import 和 from 是赋值语句！import 和 from 是赋值语句！ 就像 def 一样，import 和 from 是可执行的语句，而不是编译期间的声明，import 和 from 都是隐性的赋值语句。import 将整个模块对象赋值给一个变量名，例如 import numpy as np，变量 np 可以调用 numpy 里的对象。from 将一个或多个变量名赋值给另一个模块中的同名对象，例如from random import random，在当前模块中使用 random 变量就可以调用 random 模块的对象。 又因为 from 是复制引用模块内的变量，变成当前脚本中的对象的引用，所以通过 from 赋值的对象是不安全的： 123456789101112131415"""var.py"""x = 1y = [1,2]"""test1.py"""from var import x,y...x = 2y[0] = 9..."""test2.py"""import varprint(x) # 1print(y) # [9,2] 列表 y 是一个可变对象，在 test1 中，改变了 y 的值，在 test2 中得到了反馈，test2 中的 y 被修改。 所以，通常会建议大家使用 import 而非 from 来导入模块（而不是导入包）。from 破坏了命名空间，造成了变量名的重复甚至覆盖，或者如上例所示，同名的变量无意间修改了 var 模块中的变量。这都是不安全的隐患。而 import 通过 module.x，module.y 这样的访问方式，大大提升了代码的安全性。 导入包__init__.py要导入一个包，必须遵循一条约束：包的每一级目录都有 __init__.py 文件。 Python 首次导入某个包时，会自动执行该目录下 __init__.py 文件中的所有程序代码。因此，__init__.py 文件自然就应该是一份初始化代码。 举一个例子，我们看一下 Python Web 框架 django 中是怎么写 __init__.py 文件的： 12345"""django/django/apps/__init__.py"""from .config import AppConfigfrom .registry import apps__all__ = ['AppConfig', 'apps'] 包 apps 内有三个文件 __init__.py，config.py，registry.py。如果我们什么也不做，直接import apps，是可以成功导入的，但是在使用的时候，apps.config.AppConfig 会报错，module &#39;apps&#39; has no attribute &#39;config&#39;，Python 在这里直接导入了一个模块，而未能按照包来处理。但是在__init__.py中加入那两行代码之后，import apps相当于执行了这两个from导入。另外一种写法就是，__init__.py中不写from语句，在需要导入包的地方使用from apps import config，这样也可以实现模块的导入，同时也没有破坏命名空间。 再来看看 __all__ 变量。该变量定义了以 from ... import * 语句形式导入包时，需要导出什么。若定义了这个变量，那么使用from ... import *导入包时，并不会导入包内所有的模块的所有变量，而是只导出列表中的变量。 关于 import 的一些语法 在同级目录导入模块时，不能使用 from . import module，应该直接写import module 在同级目录下，可以写from .module import attribute Python 模块文件模板这只是一个建议，摘自廖雪峰Python教程。 1234567891011121314151617181920#!/usr/bin/env python3# -*- coding: utf-8 -*-'a test module ' # 任何模块代码的第一个字符串都被视为模块的文档注释__author__ = 'Harry Potter'import sysdef test(): args = sys.argv if len(args)==1: print('Hello, world!') elif len(args)==2: print('Hello, %s!' % args[1]) else: print('Too many arguments!')if __name__=='__main__': test() 以上。]]></content>
      <categories>
        <category>Python Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中文输入法]]></title>
    <url>%2FNotes%2F2019%2F06%2F10%2Flinux-%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[系统版本为 Ubuntu 16.04。 首先安装汉语语言包： 1$sudo apt install language-pack-zh-hans 安装谷歌拼音输入法。执行这个命令，系统会自动安装 fcitx，googlepinyin，以及一些 fcitx 配置程序： 1$sudo apt install fcitx-googlepinyin 打开 systemsettings -&gt; Language Support，系统会自动进行语言包搜索，按照系统提示确认安装。fcitx 是一个输入法框架。如图所示，在 Keyboard input method system 中选择 fcitx： 重启电脑，fcitx 输入法框架开始运行。在终端执行 fcitx-configtool，进行输入法配置。点击 “+” 添加Google Pinyin： 若列表里没有 Google Pinyin，需要取消 Only Show Current Language 复选框： 添加完输入法之后，在 Global Config 中可以看到输入法的切换方式： 以上。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文档</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux强化学习环境配置]]></title>
    <url>%2FNotes%2F2019%2F06%2F10%2Flinux-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Nvidia 驱动安装在 All Settings -&gt; Details 中查看自己的设备信息，如图： Nvidia 驱动和 CUDA 版本存在着对应关系，可以在官网查看。 这里可以查看 GPU 支持的驱动版本。 推荐使用 ppa 源安装驱动，方法如下： 首先添加 ppa 源，执行如下语句： 1$sudo add-apt-repository ppa:graphics-drivers/ppa 获取最新的软件包源，将其添加至当前 apt 库中，执行后会显示当前可供下载的最新驱动版本号，已经老的驱动版本号。如图： 最新的版本为 nvidia-410(410.66)，稍早的版本为 nvidia-390(390.87)。更新软件库信息，并下载 Nvidia 驱动： 12$sudo apt update$sudo apt install nvidia-390 安装三维图像库和 OpenGL 环境，并重启： 123$sudo apt install mesa-common-dev$sudo apt install freeglut3-dev$sudo reboot 在终端输入 nvidia-smi，若输出如下，则说明安装成功： All Setting -&gt; Details 内显示 Graphics 为 Geforce 920： 在 .bashrc 中添加路径：1$export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/nvidia-390 以上。 CUDA 安装以 cuda8 为例，参考博客。 很多博客都指出要先禁用 nouveau 服务，并加入黑名单，这个步骤很麻烦，同时也是没有必要的。首先，我们来看 nouveau 是什么。nouveau 是一个开源驱动项目，是 Linux KMS（kernel mode-setting）驱动的一部分，是一个公版的显卡驱动程序，可以驱动 AMD、高通的芯片，nvidia 也参与了开发，KMS 项目是为了在文本系统Linux中显示图形界面而诞生的开源项目。也就是说，这个 nouveau 和我们安装的 nvidia 驱动是冲突的，所以是要禁止掉的。但是，如果你的系统中两者并没有发生冲突，那么再处理这个公版驱动就没有必要了。CUDA 安装指南 Installation Guide for Linux 中指明了需要 Disable the Nouveau drivers，但是在具体如何禁用的时候，文档又指出了: The Nouveau drivers are loaded if the following command prints anything: 1$lsmod | grep nouveau 如果执行命令后什么也没有显示，则说明 Nouveau drivers 本身就没有被使用，是不用禁用的。 直接执行如下命令： 1$sudo sh cuda_8.0.61_375.26_linux.run 或者 1$sudo sh cuda_8.0.61_375.26_linux.run --no-opengl-libs # 更推荐这种方式 按照提示一步步安装即可，注意安装驱动的选项要选择 no。 然后安装补丁 Patch 2： 1$sudo sh cuda_8.0.61.2_linux.run 安装完成后，在环境变量中添加 CUDA，在 .bashrc 中添加： 12export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$LD_LIBRARY_PATH 重启电脑，即完成 CUDA 安装。 以上。 CUDNN 安装cudnn 需要注册 nvidia 账号才可以下载。共有三个文件： libcudnn6-dev_6.0.21-1+cuda8.0_amd64.deb libcudnn6_6.0.21-1+cuda8.0_amd64.deb libcudnn6-doc_6.0.21-1+cuda8.0_amd64.deb 命令行执行： 123$sudo dpkg -i libcudnn6-dev_6.0.21-1+cuda8.0_amd64.deb$sudo dpkg -i libcudnn6_6.0.21-1+cuda8.0_amd64.deb$sudo dpkg -i libcudnn6-doc_6.0.21-1+cuda8.0_amd64.deb 安装完毕后重启终端。 输入命令： 1$nvcc -V 会显示 CUDA 的版本号。 进入 ~/NVIDIA_CUDA-8.0_Sample/1_Utilities/deviceQuery/，执行 make 命令： 12$make$./deviceQuery 显示 Result = PASS。CUDA+CUDNN 安装成功。以上。 tensorflow 安装使用 pip 安装即可。首先，在 anaconda 中创建虚拟环境：1$conda create -n tf python=3.5 这里最好创建 python3.5 的环境，因为后面安装的包对更高版本的支持不是太好。tensorflow 的向下兼容性并不是很好，这里要选择好tensorflow的版本，tensorflow 和 CUDA 以及 cudnn 的版本对应关系如下，数据来自博客 tensorflow-gpu cuda cudnn python v1.9.0 9.0 7.1.4 2.7,3.3-3.6 v1.8.0 9.0 7 2.7,3.3-3.6 v1.7.0 9.0 7 2.7,3.3-3.6 v1.6.0 9.0 7 2.7,3.3-3.6 v1.5.0 9.0 7 2.7,3.3-3.6 v1.4.0 8.0 6.0 2.7,3.3-3.6 v1.3.0 8.0 6.0 2.7,3.3-3.6 v1.2.0 8.0 5.1 2.7,3.3-3.6 v1.1.0 8.0 5.1 2.7,3.3-3.6 根据之前安装的cuda和cudnn，我选择安装 tensorflow v1.4.0:12$source activate tf # 进入虚拟环境 tf$pip install tensorflow-gpu==1.4.0 # 若提示有包依赖，再安装便是 以上。 mujoco安装破解版的三个文件：mjkey.txt, mjpro150, mjpro150_linux.zip。 首先，在主目录下创建隐藏文件夹 mujoco，并将压缩包 mjpro150_linux.zip 解压到这里：1234$mkdir ~/.mujoco$cp mjpro150_linux.zip ~/.mujoco$cd ~/.mujoco$unzip mjpro150_linux.zip 然后，将 mjket.txt 复制到 ~/.mujoco 和 ~/.mujoco/mjpro150/bin :12$cp mjkey.txt ~/.mujoco$cp mjkey.txt ~/.mujoco/mjpro150/bin 复制 mjpro150 到 .mujoco 中，覆盖原有的 mjpro150 文件夹：1$cp -rf mjpro150 ~/.mujoco 修改文件执行权限：1$sudo chmod 777 -R .mujoco 然后添加环境变量，在 .bashrc 中添加：12export LD_LIBRARY_PATH=~/.mujoco/mjpro150/bin$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;export MUJOCO_KEY_PATH=~/.mujoco$&#123;MUJOCO_KEY_PATH&#125; 运行测试：12$cd ~/.mujoco/mjpro150/bin$./simulate ../model/humanoid.xml 以上。 mujoco_py 安装：首先，在 github 上下载源码：1$git clone https://github.com/openai/mujoco-py.git 下载下来的代码中包含 requirements.txt，需要先安装里面的依赖包：1$pip install -r requirements.txt 安装完依赖之后安装 mujoco_py：1$pip install -u 'mujoco-py&lt;1.50.2,&gt;=1.50.1' 安装过程中如果 gcc 报错，那么执行以下语句：1$sudo apt install libgl1-mesa-dev libgl1-mesa-glx libosmesa6-dev python3-pip python3-numpy python3-scipy 若出现错误：fatal error:GL/glew.g：没有那个文件或目录，解决方法：1sudo apt install libglew-dbg libglew-dev libglew1.10 libglew-dbg libglewmx-dev libglewmx1.13 glew-utils 安装完毕后，测试安装结果。1$cp -rf ~/Downloads/mujoco-py/xmls ~/.local/lib/python3.5/site-packages 然后执行 python 代码：12345678910import mujoco_pyfrom os.path import dirnamemodel = mujoco_py.load_model_from_path(dirname(dirname(mujoco_py.__file__))+"/xmls/claw.xml")sim = mujoco_py.MjSim(model)print(sim.data.qpos) # [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]sim.step()print(sim.data.qpos)# [2.09217903e‐06 ‐1.82329050e‐12 ‐1.16711384e‐07 ‐4.69613872e‐11# ‐1.43931860e‐05 4.73350204e‐10 ‐3.23749942e‐05 ‐1.19854057e‐13# ‐2.39251380e‐08 ‐4.46750545e‐07 1.78771599e‐09 ‐1.04232280e‐08] 以上。 安装 gym使用源码安装：1234$git clone https://github.com/openai/gym.git$cd gym$sudo apt install -y python-numpy python-dev cmake zlib1g-dev libjpeg-dev xvfb libav-tools xorg-dev python-opengl libboost-all-dev libsdl2-dev swig$pip install -e .[all] 运行测试程序：123456789101112import gymenv = gym.make('Hero-ram-v0')for i_episode in range(20): observation = env.reset() for t in range(100): env.render() print(observation) action = env.action_space.sample() observation,reward,done,info = env.step(action) if done: print("Episode finished after &#123;&#125; timesteps".format(t+1)) break 补充，安装需要依赖 cmake 和 zliblg-dev，1$sudo apt install cmake libz-dev 以上。 baseline 的安装baseline 需要 python3.5 及其以上的版本。安装依赖：1$sudo apt install libopenmpi-dev baseline 安装方法如下：123$git clone https://github.com/openai/baseline.git$cd baseline$pip install -e . 若出现错误 ERROR: GLEW initalization error: Missing GL version 解决办法为，在 .bashrc 中添加：1$export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libGLEW.so:/usr/lib/nvidia-390/libGL.so 若出现错误 AssertionError: TensorFlow needed, of version above 1.4 解决办法为：1$sudo ldconfig /usr/local/cuda/lib64/ 测试安装结果：12$cd ~/baseline/baseline/her/experiment/$python train.py --num_cpu=2 训练完毕后调用：1$python play.py /tmp/openai-2019-01-04-13-26-30-141299/policy_best.pkl # 后面这个参数是训练结束后输出的值 以上。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文档</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown入门]]></title>
    <url>%2FNotes%2F2019%2F06%2F02%2Fmarkdown%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本博客均使用 markdown 撰写，这里简单介绍一下 markdown 的语法，同时记录分享一些在编写文章的过程中遇到的问题。 markdown是一种轻量级的标记语言，通过简单的标记语法，使文本内容具有一定的格式。markdown编写的文档后缀为 .md，.markdown。 1.标题markdown标题有两种格式。 第一种，在文字前面加 # 即可使文字变为标题(#后面用空格隔开)。一个 # 是一级标题，两个是二级标题，以此类推，一共支持六级标题。示例：123# 一级标题## 二级标题##### 五级标题 效果如下： 另一种格式为在文字下方加 = 表示一级标题，加 - 表示二级标题，写法如下：1234一级标题=======二级标题------- 第二种方法由于可表示的层级略少，故不常用。 2.段落在markdown文本中输入回车并不能使文字换行，要想开始一个新的段落，需要在文字结尾加上两个以上的空格，然后再回车，或者在段落的后面使用一个空行再重新开始新的段落。 分隔线在一行中使用三个以上的星号*、减号-、下划线_、即可生成一个分割线。 下划线要想在文字下添加下划线，可以借助 HTML 的 \&lt;u> 标签来实现：1&lt;u&gt;带下划线文字&lt;/u&gt; 显示效果： 带下划线文字 删除线如果要在文字上加删除线，只需要在文字两端加上两个波浪线~ 即可。1~~这句话的意思有误~~ 显示效果： 这句话的意思有误 字形markdown可以使用以下几种字形：123456*斜体*_斜体_**粗体**__粗体__***粗斜体***___粗斜体___ 显示效果如下： 斜体_斜体_粗体粗体粗斜体粗斜体 列表markdown支持有序列表和无序列表。无序列表使用星号*、加号+或是减号-作为列表标记，符号和文字用空格隔开。123456* 第一项* 第二项+ 第一项+ 第二项- 第一项- 第二项 显示效果为： 第一项 第二项 第一项 第二项 第一项 第二项 有序列表使用数字加 . 来表示：121. 第一项2. 第二项 显示效果为： 第一项 第二项 列表的嵌套只需在子列表前方添加四个空格：123451. 第一章 1. 第1.1节 2. 第1.2节2. 第二章 1. 第2.1节 显示效果如下： 第一章 第1.1节 第1.2节 第二章 第2.1节 引用markdown引用是在段落开头使用 &gt; 符号，文字和符号用空格隔开：1&gt; 山有扶苏，隰有荷华。不见子都，乃见狂且。 效果如下： 山有扶苏，隰有荷华。不见子都，乃见狂且。 3.代码区块可以用连续的三个 ` 包裹一段代码，并指定一种语言，markdown会将其解释为一个代码区块：``` C #include &lt;stdio.h&gt;int main() { printf(“hello world\n”);}``` 这样一段上下被```包围的语句，显示为：1234#include &lt;stdio.h&gt; int main() &#123; printf("hello world\n");&#125; 在一行文字内要想添加代码，可以用`标记：1用 `len()` 函数可以获得 list 元素的个数。 用 len() 函数可以获得 list 元素的个数。 4.图片开头一个感叹号！紧跟着一个方括号，括号内可以写上图片的名称，也可以使用html的一些标签来定义图片的格式。接着一个普通括号，里面填写图片的地址，可以是网址也可以是相对路径，路径之后可以空一格用双引号添加图片名，如果添加了图片名，鼠标指向图片的时候会显示出来。1![sample](markdown入门/doge.jpg) 5.链接链接的使用方法如下：[链接名称](链接地址)或者&lt;链接地址&gt;例如：我的个人博客实现代码为：1[我的个人博客](https://mr-solution.github.io/Notes/) 锚点在页面内设置锚点可以让我们迅速跳转到页面的指定位置，在较长的文章中可以为读者的阅读提供便利。添加锚点的具体方法如下。 假设我们需要在章节 2.1 处添加一个锚点——“欲知后事如何，且看2.1节”，文字 2.1 是一个链接，读者点击之后就可以立即跳转到 2.1 节。此时我们需要做的是先在2.1节处设置锚点，具体语法为：12&lt;a id="name1"&gt;2.1&lt;/a&gt; &lt;!-- html5 使用属性id替换了属性name --&gt;&lt;a name="name1"&gt;2.1&lt;/a&gt; &lt;!-- html5中不在支持name属性--&gt; &lt;a&gt;是html标签，用来定义超链接，属性id指定了锚点的名字，在需要跳转的地方我们可以这样写：1欲知后事如何，且看&lt;a href="#name1"&gt;2.1&lt;/a&gt;节 &lt;!-- name1前面要加# --&gt; 这样文本中的2.1就会变成一个链接，点击即可跳转到2.1节的位置。 6.表格markdown制作表格使用|来分隔单元格，使用-来分隔表头和其他行。语法格式如下：1234|表头|表头||-|-||单元格|单元格||单元格|单元格| 以上代码显示结果如下： 表头 表头 单元格 单元格 单元格 单元格 我们还可以设置表格的对齐方式： -:设置内容右对齐 :-设置内容左对齐 :-:设置内容居中对齐 上边的代码修改一下：1234|表头|表头||:-:|-:||单元格|单元格||单元格|单元格| 显示效果如下： 表头 表头 单元格 单元格 单元格 单元格]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 随机数]]></title>
    <url>%2FNotes%2F2019%2F05%2F21%2FPython-%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有这样一个场景：在蛇棋游戏中，总共有 100 个格子，其中有 ladder_num 个格子中有梯子，梯子的作用是让棋子直通到另外一个格子中。用 python 实现梯子功能的代码片段如下： 123ladders = dict(np.random.randint(1, 100, size=(ladder_num, 2)))for k,v in ladders.items(): ladders[v] = k np.random.randint(1,100,size=(ladder_num, 2)) 意思是随机生成一个 ladder_num x 2 的二维数组，数组中每一个元素的大小在 1 到 100 之间。然后将二维数组转换为 dict，其中 key 代表起始的格子编号，value 代表指向的格子编号，梯子由 key 指向 value。再用一个循环将梯子由 value 指向 key，说明梯子是双向的。这里有两个问题。第一，随机数是不可控的，在 ladder_num 个数据对中很有可能会出现相同的数字，dict() 函数是有去重功能的，假设存在数据对 [[2,8],[2,15]]，那么最终保留在 dict 中的 key 值 2，对应的 value 只有 15。这就造成了数据丢失，若我们的目的是为了生成 10 个梯子，这样最终只能生成 9 个梯子。第二，假设随机生成的数据对为[...,[45,48],[65,68],[68,10],...]，那么后面的循环就会出现问题，因为dict中 key 65 对应的 value 为 68，循环中反转 kv，得到一个 key 68 指向 value 65，但是dict中已经有值为 68 的 key 了，它指向 value 10，这里就对原来的梯子做了修改。更严重的是，这里会报错RuntimeError: dictionary changed size during iteration，这是因为 Python 3 是不允许在遍历中修改字典大小的。 可以将代码修改如下：1234ladders = np.random.randint(1, 100, size=(ladder_num, 2))for k,v in ladders: ladders = np.vstack((ladders, np.array([v,k])))ladders = dict(ladders) 但是这样依然无法解决第一个问题，ladders 这个字典的大小依然可能小于我们希望的 ladder_num。为了得到不重复的 N 个随机数，我们有两个方法：第一，使用random.sample(range(A,B),N)函数，表示从[A,B]区间随机生成 N 个数，结果以列表返回。第二，使用 numpy 的函数np.random.sample(size)，该函数返回一个 size 数组，元素在[0.0, 1.0)区间：12345ladders = np.random.sample((ladder_num, 2)) * (100 - 0)ladders = ladders.astype(int)for k,v in ladders: ladders = np.vstack((ladders, np.array([v,k])))ladders = dict(ladders) 关于随机数 seed若不设置 seed，则每次会生成不同的随机数；若设置了 seed，则相当于设置了随机数生成的起点，后续生成的随机数都将是确定的。 1234567891011121314import randomrandom.seed()print ("使用默认种子生成随机数：&#123;&#125;".format(random.randint(1,5)))random.seed(10)for i in range(3): print ("使用种子10生成随机数：&#123;&#125;".format(random.randint(1,5))) print ("使用种子10生成随机数：&#123;&#125;".format(random.randint(1,5)))print("******************************")for i in range(3): random.seed(10) print ("使用种子10生成随机数：&#123;&#125;".format(random.randint(1,5))) print ("使用种子10生成随机数：&#123;&#125;".format(random.randint(1,5))) 第一个循环生成 6 个随机数：5，1，4，4，5，1。这相当于随机数种子 10 所能生成的随机数序列的前六个数字。第二个循环每次只取该序列的前两个数字：5，1。第二个循环的输出为：5，1，5，1，5，1。]]></content>
      <categories>
        <category>Python Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串]]></title>
    <url>%2FNotes%2F2019%2F05%2F21%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串的访问跟列表一样，用方括号访问，支持切片操作。python 支持格式化字符串的输出，最基本的用法是字符串中插入 %s： 12print("My name is %s." % ("LiLei"))str = "Her name is %s" % ("HanMeimei") 具体的字符串格式符同 C 语言一样。从 Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。其基本语法是通过 {} 和 : 来代替以前的 %。format() 函数可以接受不限个参数，位置可以不按顺序。12345&gt;&gt;&gt;"&#123;&#125; &#123;&#125;".format("hello", "world") # 不设置指定位置，按默认顺序'hello world'&gt;&gt;&gt;"&#123;0&#125; &#123;1&#125;".format("hello", "world") # 设置指定位置&gt;&gt;&gt;"&#123;0&#125; &#123;1&#125; &#123;0&#125;".format("hello", "world")hello world hello]]></content>
      <categories>
        <category>Python Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯 naive bayes]]></title>
    <url>%2FNotes%2F2019%2F02%2F27%2F%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF-naive-bayes%2F</url>
    <content type="text"><![CDATA[贝叶斯公式]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Guide]]></title>
    <url>%2FNotes%2F2019%2F01%2F23%2Flinux-guide%2F</url>
    <content type="text"><![CDATA[IntroductionLinuxLinux是一个免费的类 unix 操作系统，基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。以网络为核心，性能稳定。Windows 操作系统跟 Linux 操作系统在设计哲学上存在着巨大的区别。Windows 系统将各种功能都集中的操作系统内部，而 Linux 的内核空间与用户空间有明显的界限。Windows 的设计是为了让用户更方便的交互，所以对图形化界面 GUI 的支持特别好。Linux 操作系统以网络为核心，以文本为信息的载体，Linux 的核心设计思想为：一切皆为文件，所以它本质上是一个基于文本的命令行操作系统，图像对 Linux 系统来说是个包袱，Linux 对 GUI 的支持是很差的，GUI 在一定程度上会影响系统的稳定性，Linux 服务器均没有图形界面。 严格来讲，Linux 是指 Linux Kernel，我们平时用到的 Linux OS 一般都是基于这个 Kernel 制作的发行版（Redhat, debian, Centos, SuSE, Fedora等）。Ubuntu 基于debian，Centos 基于 Redhat，debian 基础核心小，稳定，占用资源少，Centos 去除了很多与服务器无关的应用，系统简单稳定。二者都是非常适合做服务器的操作系统。 Linux 本身没有图形界面，linux 是一个基于命令行的操作系统，图形界面得益于 X windows。 X WindowsX Windows (1984诞生于 MIT) 也被叫做“X”，“X 11”，是为了在 UNIX 系统上使用图形界面而开发的系统。X 一开始就是针对网络而设计的，采用了“client-server”模型，“X server”运行在计算机上，用来管理显示信息，处理来自键盘和鼠标的输入信息，并与其他输入输出设备交互。每一个 X 应用程序（比如 XTerm，Terminal，浏览器等）就是一个“X client”，客户给服务器发信息，例如：”请在这些坐标显示鼠标轨迹“等等。 如果只有一台计算机，那么可以在同一台计算机上运行 X server 和 X client，当有多台计算机的时候，可以在一台计算机上运行 X 应用程序，通过网络传递信息，在另一台计算机上接收信息，并由 X server 处理，由本机 X client 显示。例如 Exceed、telnet、teamviewer 等远程 X window软件。 严格地说，X 并不是一个软件，它更类似于 HTTP 协议、IP 协议，一个基于 X 的应用程序需要运行并显示内容的时候，就连接到 X 服务器，用 X 协议和服务器交谈，X 服务器提供一些接口供客户使用。同时，X 服务器还负责捕捉键盘和鼠标的动作，并通知 X 程序。 我们打开 Ubuntu 16 系统，看到的桌面系统默认为 Unity 7。常用的桌面系统还有 KDE、Gnome、xfce等。这些桌面系统都集成了 X Windows，它们与基本系统的耦合度都很低，这种低耦合的优点在于，当图形界面出问题的时候，可以进入命令行模式（ctrl+alt+F1-F6）进行修复。 Linux 图形界面层次关系如下： Linux kernel --> X server &lt;-- X 协议 --> 桌面环境 --> X 应用程序。 Shellshell 是命令解释器，它解释由用户输入的命令并把它们送到内核，是用户使用 Linux 的桥梁。用户通过 shell 同 kernel 交互，shell 就像是包裹在 kernel 外面的一层蛋壳，故名 shell。有很多人用不同的方式编写实现了这种命令解释器，shell 是这些软件的统称，它是独立于 Linux kernel 的一种软件，一般的 Linux 发行版都使用 Bash 解释器。 shell 软件虽然有很多种，但是它们都是使用文本指令，而且这些文本指令都是一样的。不管使用的什么发行版的系统，使用的什么类型的图形界面，文本指令都是统一的，用户可以很方便地在不同的发行版间切换，另外，文字指令在远程联机的时候有无可比拟的速度优势。因此，牢记一些常用的 shell 指令是很有必要的。 常用的 Bash 命令Bash 是一个为 GNU 计划编写的 Unix shell，是在 Bourne shell(史蒂夫·伯恩于1978年编写)的基础上编写的，全称为 Bourne-Again shell(这是一个双关语 Bourne again/born again)。 文件与目录前面提过，Unix/Linux 的设计思想是：一切皆文件。Linux 内的所有的一切都是以字节流的形式来呈现的，包括进程、线程、套接字、IO设备等等。所以整个 Linux 系统最重要的地方就是目录树结构。所谓的目录树结构就是以根目录为主，向下呈现分支状的目录结构。整个目录树最重要的就是根目录（root directory，表示方法为 “/“）。目录树结构如下图所示： 目录中不同的路径可以存储在不同的分区，这在 Linux 中叫做挂载，必须将文件所在的分区挂载到一个已存在的目录上，才能通过访问这个目录来访问存储设备。例如，根目录放在磁盘分区1，etc、lib 存储在磁盘分区2，就说分区1是挂载到根目录的，分区2是挂载到etc、lib的。 打开 shell 程序之后，我们看到如图所示： reeves 是当前用户名，rebuntu 是计算机名称，”~”表示当前所处的位置，命令 pwd 可以让我们查看当前所处位置的绝对路径：/home/reeves，第一个”/“不是分隔符，而是根目录，第二个”/“是一个分隔符，/home/reeves == ~，”~”有时候也被称为用户的主目录。 命令 ls，可以让我们查看当前路径下都有什么： ls 是 list 的缩写，列出当前路径下的文件，是 Linux 中最常用的一个命令。打开文件管理器可以看到显示的就是 Home 路径。 ls 命令后面可以加参数与选项，常用的有： -a ：列出全部文件，包括隐藏文件（名字开头为 . 的文件） -l ：列出文件的信息，包含文件的属性与访问权限。显示结果共有 10 列：第1列表明文件类型，其中-代表普通文件，d代表目录文件，c代表字符设备文件，s代表套接字文件，l代表链接文件，p代表管理文件；234列表明文件所有者的读(r)写(w)和执行(x)权限；567列表明文件的组用户权限(组中除所有者外其他人)；8-10列表明其他用户的权限。 执行命令 ls -a，我们发现有两个很特殊的目录，”.” 和 “..” ，在 Linux 中，”.” 是指当前目录，而 “..” 是指上一级目录，命令 cd .. 即可返回上一级目录。 cd 是 Linux 系统中另外一个常用的命令，是 change directory 更换目录的缩写，直接执行 cd 而不加路径的话会默认跳转至用户主目录。cd .. 会返回上一级目录，cd - 则会跳转到上一次访问的路径。 mkdir 命令可以创建新的文件夹，但是文件夹必须一层一层的一次创建，例如，要创建路径： /home/reeves/WorkSpace/pySpacce/test，必须先在路径 /home/reeves 下创建 WorkSpace，然后进入 WorkSpace 中创建 pySpace，再进入 pySpace 创建 test。加上 -p 选项则可以自动依序创建目录。 touch 命令有两个作用，一是创建新的空白文件，二是将已存在的文件的时间标签修改为当前时间（或指定时间）。第一个作用是 touch 命令通常用途。第二个作用在大型项目的编译时会用到。 1$touch hello.txt Ubuntu 自带的程序 gedit 可以打开 hello.txt 文档，并编辑内容。在命令行查看文件内容可以用 cat 命令： 1$cat hello.txt Linux 源码中的 workqueue.c 文件，有5800多行，直接 cat workqueue.c 会显示所有的内容，一屏显示不下，这时候要想查看文件开头几行，可以用 head 命令： 1$head workqueue.c 默认显示文件的前十行文件，要查看指定几行，可以用参数 -n： 1$head -n 20 workqueue.c 要查看文件的后几行，可以使用 tail 命令： 1$tail workqueue.c 依然默认显示10行内容，同 head 命令一样，-n 选项可以指定查看的行数。 tail 命令有一个很实用的用法，-f 选项可以监视文件尾部内容的改动，ctrl+c 可以退出监控。 rm 命令（remove）的作用是删除文件，是一个十分常用但是非常危险的命令。 三个重要的选项与参数： -f ：就是 force 的意思，强制执行，不会出现警告信息； -i ：互动模式，在删除之前会询问使用者是否确定删除； -r ：递归删除，常用于删除目录，是一个非常危险的选项。 1$rm -rf * # 删除当前目录下的一切文件，且不会有任何询问 可执行文件：创建 welcome.c，编译生成可执行文件 welcom，linux 下可执行文件跟 Windows 下的 exe 扩展名不一样，Linux 文件是否可以执行，可以通过 ls -l 查看文件属性列表中是否有 x。执行文件的方法为： 12$gcc welcome.c -o welcome # 编译生成可执行文件$./welcome # '.'表示当前目录，'./'表示当前目录下的可执行文件 权限chmod 命令可以改变文件的权限： 1$chmod 777 test # 执行命令 ls -l test，显示结果为 -rwxrwxrwx 文本编辑vi/vim 是一个文本编辑器，类 Unix 系统都会内置 vi 编辑器，vim 是 vi 的升级版本，两者的用法是一样的。 vim 一共有 3 个模式：正常模式，编辑模式，命令模式。 正常模式一般用于浏览文本，使用命令 vim a.c 即可打开文本，在这个模式中，键盘操作都不会键入相应的字符，而是执行相应的功能： 上下左右键和 hjkl 键可以调整光标的位置。 ctrl+f 向下翻一页 ctrl+b 向上翻一页 dd 删除光标所在行 yy 复制光标所在行 p 粘贴 u 撤销上一次操作 v 可视化选择，可以通过上下左右键来扩大选中范围 gU 选中部分变大写 gu 选中部分变小写 gg 跳转到文件首行 G 跳转到文件末尾 数字加gg 跳转到指定行 i 进入编辑模式(insert 模式)，按 Esc 退出编辑模式。 ctrl+s 锁定窗口，什么操作都不会有响应 ctrl+q 解锁窗口 编辑模式中键盘操作均作为键盘输入，要移动光标只能用上下左右键操作： Esc 退出编辑模式。 如果在退出之前希望保存所作的修改，那么需要进入命令模式。按”:”或者”/“即可进入。 :w 保存 :q 退出vim :wq 保存并退出 :q! 取消修改并退出 :set nu 显示文件的行号 :set nonu 取消行号显示 :sp 把当前窗口水平分割成两个窗口，后面可以加文件名 sp filename，ctrl+w+j/k上下屏切换 :vsp 把当前窗口竖直分割成两个窗口，后面可以加文件名 vsp filename，ctrl+w+h/l左右屏切换 /someword 匹配输入的someword，n：向后查找下一个，N：向前查找下一个 磁盘df 命令是列出文件系统的整体磁盘空间使用情况。 参数： -h : 以人们易读的GB、MB、KB等格式显示。 -m：以MB为单位展示。 -k：以KB为单位展示。 du 命令是查看当前指定文件或目录占用的磁盘空间大小。 参数： -h：以KB，MB，GB等格式显示。 -s：只显示总计。 -m：以MB为单位展示。 -k：以KB为单位展示。 压缩和打包Linux 环境中，压缩文件的扩展名大多是：.tar, .tar.gz, .tgz, .gz, .Z, .bz2。 *.Z compress 程序压缩的文件 *.gz gzip 程序压缩的文件 *.bz2 bzip2程序压缩的文件 *.tar tar程序打包的文件，没有经过压缩 *.tar.gz tar程序打包的文件，并经过gzip压缩 *.tar.bz2 tar程序打包的文件，并经过bzip2压缩 目前主流的压缩技术只有 gzip 和 bzip2，compress 基本上已经被取代，bzip2 理论上是最新最好的压缩方法。 gzip 是应用最广的压缩指令。所生成的压缩文件扩展为 *.gz，压缩和解压指令为： 12$gzip hello.c$gzip -d hello.c.gz -d 是 decompress的意思。 bzip2 可以提供更好的压缩率，生成的文件扩展为 *.bz2。压缩和解压指令为： 12$bzip2 hello.c$bzip2 -d hello.c.bz2 压缩命令只能压缩单个文件，不能压缩目录，如果要压缩目录，需要用到 tar 打包命令。 选项与参数： -c：打包目录 -x：解包目录 -z：用 gzip 压缩/解压 -j：用 bzip2 压缩/解压 -f：要处理的文件名。压缩的时候要指明压缩后的名称和要处理的目录名 -v：处理过程中显示正在处理的文件。 在 Linux 中遇到打包压缩的文件，可以根据后缀名选择相应的命令。 软件下载和安装apt (advanced packaging tool)是 Linux 下的一款安装包管理工具。常用的命令如下： apt update 从软件源服务器获取最新的软件信息并缓存到本地 apt upgrade 从本地仓库中对比系统中所有已安装的软件，如果有新版本的话进行升级 apt list 列出本地仓库中所有的软件包名 apt install 安装指定的包 apt remove 卸载指定的包，但不删除相关配置文件 apt purge 卸载指定的包，同时删除相关配置文件 apt autoremove 卸载目前不再依赖的孤立的包 dpkg (Debian packager)命令可以用来安装、删除 Debian 的软件包。与apt 不同的是，dpkg 指定的软件必须是已经下载到本地的 *.deb 文件。 常用命令如下： dpkg -i 安装指定软件 dpkg -r 删除软件包，保留其配置 dpkg -P 移除软件，不保留配置 Bash &amp;&amp; Shell数据流重定向和管道命令数据流重定向就是将本该在屏幕上出现的内容重定向到一个文件中。具体的做法就是在命令之后添加”&gt;”或者”&gt;&gt;”，其中”&gt;”的意思是将左侧命令产生的输出写入右侧文件中去，写入是以覆盖的方式进行的。”&gt;&gt;”的意思是将左侧命令产生的输出写入右侧文件中去，写入是以累加的方式进行的。12$ls &gt; result.txt # 将 ls 的结果写入到 result.txt 中去$cat &gt; hello.txt # 支持键盘输入内容到 hello.txt 文件中去 ；&amp;&amp; || 很多时候，我们想要一次输入多个命令时，可以用 ： cmd1; cmd2; … cmd1和cmd2直接没有相关性 cmd1 &amp;&amp; cmd2 cmd1运行完毕且正确则运行cmd2，否则不运行 cmd1 || cmd2 若cmd1运行完毕且正确，则cmd2不运行。否则cmd2运行 管道命令 管道命令的符号是 |，cmd1 | cmd2。即用 cmd2 来处理 cmd1 产生的结果。 统计目录下的文件数量：1$ls | wc -l 显示文件名中包含“text”的文件：1$ls | grep "text" bashrc/etc/profile 文件是一个系统级的 profile 文件。因为 Linux 是一个多用户的系统，允许每一个用户有不同的配置文件，但是每一个使用系统的用户都会先载入 /etc/profile 的配置。这个脚本会读取 /etc/profile.d/*.sh ，这里面有一些 bash 程序的配置，命令的别名等等。 bash 在载入了整体环境配置之后再依序载入 ~/.profile 文件和 ~/.bashrc 文件。 一般对于个人用户，要想添加可执行程序的路径，或者定义 bash 命令就要修改 ~/.bashrc 文件。 linux 常用软件安装与强化学习环境配置汉语输入法首先安装汉语语言包： 1$sudo apt install language-pack-zh-hans 安装谷歌拼音输入法。执行这个命令，系统会自动安装 fcitx，googlepinyin，以及一些 fcitx 配置程序： 1$sudo apt install fcitx-googlepinyin 打开 systemsettings -&gt; Language Support，系统会自动进行语言包搜索，按照系统提示确认安装。fcitx 是一个输入法框架。如图所示，在 Keyboard input method system 中选择 fcitx： 重启电脑，fcitx 输入法框架开始运行。在终端执行 fcitx-configtool，进行输入法配置。点击 “+” 添加Google Pinyin： 若列表里没有 Google Pinyin，需要取消 Only Show Current Language 复选框： 添加完输入法之后，在 Global Config 中可以看到输入法的切换方式： 以上。 Nvidia 驱动安装在 All Settings -&gt; Details 中查看自己的设备信息，如图： Nvidia 驱动和 CUDA 版本存在着对应关系，可以在官网查看。 这里可以查看 GPU 支持的驱动版本。 推荐使用 ppa 源安装驱动，方法如下： 首先添加 ppa 源，执行如下语句： 1$sudo add-apt-repository ppa:graphics-drivers/ppa 获取最新的软件包源，将其添加至当前 apt 库中，执行后会显示当前可供下载的最新驱动版本号，已经老的驱动版本号。如图： 最新的版本为 nvidia-410(410.66)，稍早的版本为 nvidia-390(390.87)。更新软件库信息，并下载 Nvidia 驱动： 12$sudo apt update$sudo apt install nvidia-390 安装三维图像库和 OpenGL 环境，并重启： 123$sudo apt install mesa-common-dev$sudo apt install freeglut3-dev$sudo reboot 在终端输入 nvidia-smi，若输出如下，则说明安装成功： All Setting -&gt; Details 内显示 Graphics 为 Geforce 920： 在 .bashrc 中添加路径：1$export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/nvidia-390 以上。 CUDA 安装以 cuda8 为例，参考博客。 很多博客都指出要先禁用 nouveau 服务，并加入黑名单，这个步骤很麻烦，同时也是没有必要的。首先，我们来看 nouveau 是什么。nouveau 是一个开源驱动项目，是 Linux KMS（kernel mode-setting）驱动的一部分，是一个公版的显卡驱动程序，可以驱动 AMD、高通的芯片，nvidia 也参与了开发，KMS 项目是为了在文本系统Linux中显示图形界面而诞生的开源项目。也就是说，这个 nouveau 和我们安装的 nvidia 驱动是冲突的，所以是要禁止掉的。但是，如果我们已经通过 ppa 安装好了 nvidia 显卡驱动，那么再处理这个公版驱动就没有必要了。CUDA 安装指南Installation Guide for Linux 中指明了需要 Disable the Nouveau drivers，但是在具体如何禁用的时候，文档又指出了: The Nouveau drivers are loaded if the following command prints anything: 1$lsmod | grep nouveau 如果执行命令后什么也没有显示，则说明 Nouveau drivers 本身就没有被使用，所以是不用禁用的。 直接执行如下命令： 1$sudo sh cuda_8.0.61_375.26_linux.run 或者 1$sudo sh cuda_8.0.61_375.26_linux.run --no-opengl-libs # 更推荐这种方式 按照提示一步步安装即可，注意安装驱动的选项要选择 no。 然后安装补丁 Patch 2： 1$sudo sh cuda_8.0.61.2_linux.run 安装完成后，在环境变量中添加 CUDA，在 .bashrc 中添加： 12export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$LD_LIBRARY_PATH 重启电脑，即完成 CUDA 安装。 以上。 CUDNN 安装cudnn 需要注册 nvidia 账号才可以下载。共有三个文件： libcudnn6-dev_6.0.21-1+cuda8.0_amd64.deb libcudnn6_6.0.21-1+cuda8.0_amd64.deb libcudnn6-doc_6.0.21-1+cuda8.0_amd64.deb 命令行执行： 123$sudo dpkg -i libcudnn6-dev_6.0.21-1+cuda8.0_amd64.deb$sudo dpkg -i libcudnn6_6.0.21-1+cuda8.0_amd64.deb$sudo dpkg -i libcudnn6-doc_6.0.21-1+cuda8.0_amd64.deb 安装完毕后重启终端。 输入命令： 1$nvcc -V 会显示 CUDA 的版本号。 进入 ~/NVIDIA_CUDA-8.0_Sample/1_Utilities/deviceQuery/，执行 make 命令： 12$make$./deviceQuery 显示 Result = PASS。CUDA+CUDNN 安装成功。以上。 tensorflow 安装使用 pip 安装即可。首先，在 anaconda 中创建虚拟环境：1$conda create -n tf python=3.5 这里最好创建 python3.5 的环境，因为后面安装的包对更高版本的支持不是太好。tensorflow 的向下兼容性并不是很好，这里要选择好tensorflow的版本，tensorflow 和 CUDA 以及 cudnn 的版本对应关系如下，数据来自博客 tensorflow-gpu cuda cudnn python v1.9.0 9.0 7.1.4 2.7,3.3-3.6 v1.8.0 9.0 7 2.7,3.3-3.6 v1.7.0 9.0 7 2.7,3.3-3.6 v1.6.0 9.0 7 2.7,3.3-3.6 v1.5.0 9.0 7 2.7,3.3-3.6 v1.4.0 8.0 6.0 2.7,3.3-3.6 v1.3.0 8.0 6.0 2.7,3.3-3.6 v1.2.0 8.0 5.1 2.7,3.3-3.6 v1.1.0 8.0 5.1 2.7,3.3-3.6 根据之前安装的cuda和cudnn，我选择安装 tensorflow v1.4.0:12$source activate tf # 进入虚拟环境 tf$pip install tensorflow-gpu==1.4.0 # 若提示有包依赖，再安装便是 以上。 mujoco安装破解版的三个文件：mjkey.txt, mjpro150, mjpro150_linux.zip。 首先，在主目录下创建隐藏文件夹 mujoco，并将压缩包 mjpro150_linux.zip 解压到这里：1234$mkdir ~/.mujoco$cp mjpro150_linux.zip ~/.mujoco$cd ~/.mujoco$unzip mjpro150_linux.zip 然后，将 mjket.txt 复制到 ~/.mujoco 和 ~/.mujoco/mjpro150/bin :12$cp mjkey.txt ~/.mujoco$cp mjkey.txt ~/.mujoco/mjpro150/bin 复制 mjpro150 到 .mujoco 中，覆盖原有的 mjpro150 文件夹：1$cp -rf mjpro150 ~/.mujoco 修改文件执行权限：1$sudo chmod 777 -R .mujoco 然后添加环境变量，在 .bashrc 中添加：12export LD_LIBRARY_PATH=~/.mujoco/mjpro150/bin$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;export MUJOCO_KEY_PATH=~/.mujoco$&#123;MUJOCO_KEY_PATH&#125; 运行测试：12$cd ~/.mujoco/mjpro150/bin$./simulate ../model/humanoid.xml 以上。 mujoco_py 安装：首先，在 github 上下载源码：1$git clone https://github.com/openai/mujoco-py.git 下载下来的代码中包含 requirements.txt，需要先安装里面的依赖包：1$pip install -r requirements.txt 安装完依赖之后安装 mujoco_py：1$pip install -u 'mujoco-py&lt;1.50.2,&gt;=1.50.1' 安装过程中如果 gcc 报错，那么执行以下语句：1$sudo apt install libgl1-mesa-dev libgl1-mesa-glx libosmesa6-dev python3-pip python3-numpy python3-scipy 若出现错误：fatal error:GL/glew.g：没有那个文件或目录，解决方法：1sudo apt install libglew-dbg libglew-dev libglew1.10 libglew-dbg libglewmx-dev libglewmx1.13 glew-utils 安装完毕后，测试安装结果。1$cp -rf ~/Downloads/mujoco-py/xmls ~/.local/lib/python3.5/site-packages 然后执行 python 代码：12345678910import mujoco_pyfrom os.path import dirnamemodel = mujoco_py.load_model_from_path(dirname(dirname(mujoco_py.__file__))+"/xmls/claw.xml")sim = mujoco_py.MjSim(model)print(sim.data.qpos) # [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]sim.step()print(sim.data.qpos)# [2.09217903e‐06 ‐1.82329050e‐12 ‐1.16711384e‐07 ‐4.69613872e‐11# ‐1.43931860e‐05 4.73350204e‐10 ‐3.23749942e‐05 ‐1.19854057e‐13# ‐2.39251380e‐08 ‐4.46750545e‐07 1.78771599e‐09 ‐1.04232280e‐08] 以上。 安装 gym使用源码安装：1234$git clone https://github.com/openai/gym.git$cd gym$sudo apt install -y python-numpy python-dev cmake zlib1g-dev libjpeg-dev xvfb libav-tools xorg-dev python-opengl libboost-all-dev libsdl2-dev swig$pip install -e .[all] 运行测试程序：123456789101112import gymenv = gym.make('Hero-ram-v0')for i_episode in range(20): observation = env.reset() for t in range(100): env.render() print(observation) action = env.action_space.sample() observation,reward,done,info = env.step(action) if done: print("Episode finished after &#123;&#125; timesteps".format(t+1)) break 补充，安装需要依赖 cmake 和 zliblg-dev，1$sudo apt install cmake libz-dev 以上。 baseline 的安装baseline 需要 python3.5 及其以上的版本。安装依赖：1$sudo apt install libopenmpi-dev baseline 安装方法如下：123$git clone https://github.com/openai/baseline.git$cd baseline$pip install -e . 若出现错误 ERROR: GLEW initalization error: Missing GL version 解决办法为，在 .bashrc 中添加：1$export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libGLEW.so:/usr/lib/nvidia-390/libGL.so 若出现错误 AssertionError: TensorFlow needed, of version above 1.4 解决办法为：1$sudo ldconfig /usr/local/cuda/lib64/ 测试安装结果：12$cd ~/baseline/baseline/her/experiment/$python train.py --num_cpu=2 训练完毕后调用：1$python play.py /tmp/openai-2019-01-04-13-26-30-141299/policy_best.pkl # 后面这个参数是训练结束后输出的值 以上。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++ 读书笔记 03：尽可能使用const]]></title>
    <url>%2FNotes%2F2019%2F01%2F22%2FEffective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-03%2F</url>
    <content type="text"><![CDATA[const 允许你指定一个语义约束，而编译器会强制执行这项约束，确保某个对象不会被改变。如果某个对象在执行中不应该（或者不会）被改变，就应该使用 const。 一. const 修饰变量看下面一段代码： 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; int a = 1; //non-const data const int b = a; //const data int *c = &amp;a; //non-const data,non-const pointer const int *d = &amp;a; //const data,non-const pointer int * const e = &amp;a; //non-const data,const pointer const int * const f = &amp;a; //const data,const pointer const int * const g = &amp;a; //const data,const pointer return 0;&#125; const 修饰指针的时候，const 在 * 号右边表示指针是 const 的，在 * 左边，表示 *p（即指针指向的对象），是 const 的。在 STL 迭代器的应用中，map&lt;int, int&gt;::const_iterator itr 相当于 const T* itr，即迭代器（指针）itr 指向的对象 *itr 是 const 的，而 const map&lt;int, int&gt;::iterator itr 相当于 T* const itr，即迭代器 itr 是 const 的。 在上边代码中，若 a 的值被改变了，那么除 b 外，*c， *d， *e， *f， *g 都会改变，因为 b 的赋值是 copy 赋值立即数，之后的 b 就跟 a 没有关系了，但对 c-g 而言，修饰它们的 const 仅仅表示，不能修改指针的值或者通过 *p 修改指针指向的变量，但 a 并不是 const data，所以可以通过修改 a 的值来改变指针 cdefg 指向的值。 使用 const 需要注意，const 对象必须初始化（因为它不能改变不能接受再次的赋值）（但并不一定在声明的同时给予初值）。在函数中声明 const 需要立即给初值，在类 class 中声明的时候，不能立即赋值，这是因为 const 数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的（这点与 static 相反），类可以创建多个对象，相应的 const 成员的初始化只能在类的构造函数的初始化表中进行： 1234567class Stuff &#123;public: Stuff(int m) : max_num(m) &#123; &#125;;private: const int max_num;&#125;; 要想建立在整个类中都恒定的常量，应该用类中的枚举常量或者 static 来实现。 二. const 修饰成员函数const 成员函数的声明：const 关键字只能放在函数声明的尾部！ 123int func() const &#123; return 0;&#125; const 修饰的成员函数不能修改这个类对象的任何的数据成员（准确地说是非静态数据成员）。 const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可以会修改成员变量。 在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要声明为const 成员函数。有 const 修饰的成员函数（const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。 这样做好处在于，首先，类的接口更容易被理解，一看便知函数是读操作还是有写操作；其次，将成员函数声明为 const 使得该函数操作 const 对象成为可能，因为常量（即 const）对象可以调用 const 成员函数，而不能调用非 const 修饰的函数。 ps：之所以我们希望函数可以操作 const 对象是因为处于程序的效率考虑，传引用或者指针往往比传值要好，传引用的时候为了防止对象被修改，往往要声明为 const 引用或指针，const 对象不能调用非 const 函数，所以，尽可能的将只有读操作的函数声明为 const 函数。 注意：两个成员函数如果只是常量性不同，是可以被重载的，原因在于函数的形参列表里隐藏有 this 指针，const 函数里 this 指针是指向 const 对象的指针，而非 const 函数里的 this 指针是正常版本的指针。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;class Chinese &#123;public: Chinese() &#123; personID = IdentityCardId; IdentityCardId++; &#125; int getNation() const&#123; cout &lt;&lt; "CHINA ID : " &lt;&lt; personID &lt;&lt; endl; IdentityCardId++; return 0; &#125; int getNation() &#123; cout &lt;&lt; "china ID : " &lt;&lt; personID &lt;&lt; endl; return 0; &#125;private: static int IdentityCardId; int personID;&#125;;int Chinese::IdentityCardId = 1;int main() &#123; const Chinese LaoWang = Chinese(); LaoWang.getNation(); //输出CHINA ID:1，const对象LaoWang默认调用const成员函数，并且可以修改static变量IdentityCardId Chinese LaoSun = Chinese(); LaoSun.getNation(); //输出china ID:3，non_const对象LaoSun默认调用non_const的成员函数 return 0;&#125; const 对象默认调用 const 成员函数，非 const 默认调用 const 成员函数，类中只有一个函数存在的情况下（我们删掉 non_const 版本的 getNation()），non_const 的对象也可以调用非 const 成员函数。 三. const 修饰函数返回值如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加 const 修饰的同类型指针。例如函数: 1const char * GetString(void); 如下语句将出现编译错误： 1char *str = GetString(); 正确的用法是: 1const char *str = GetString(); 如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加 const 修饰没有任何意义。 例如不要把函数: 1int GetCnt(); 写成: 1const int GetCnt(); 同理不要把函数(T为自定义数据类型): 1T getT(void); 写成 1const T getT(void); 如果返回值不是内部数据类型，将函数 T getT(void) 改写为 const T &amp; getT(void) 的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。 函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。（除了重载操作符外一般不要将返回值类型定为对某个对象的 const 引用！） 例如： 1234567class A &#123; A &amp; operate = (const A &amp;other); // 赋值函数&#125;;A a, b, c; // a, b, c 为A 的对象a = b = c; // 正常的链式赋值(a = b) = c; // 不正常的链式赋值，但合法 如果将赋值函数的返回值加 const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2FNotes%2F2019%2F01%2F20%2Ftest%2F</url>
    <content type="text"><![CDATA[Hello World!Welcome to visit my blog!this my first blog. papers coding books 11 11 1111 123 456 789]]></content>
      <categories>
        <category>测试文档</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FNotes%2F2019%2F01%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试文档</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>文档</tag>
      </tags>
  </entry>
</search>
